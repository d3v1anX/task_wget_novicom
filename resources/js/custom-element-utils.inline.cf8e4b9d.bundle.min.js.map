{"version":3,"file":"custom-element-utils.inline.cf8e4b9d.bundle.min.js","mappings":"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","sources":["webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imageServiceConstants.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imageServiceFeatureSupportObject.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/populateFeatureSupport.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/utils.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imageServiceUtils.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/engines/attributes/backgroundAttributes.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/engines/attributes/imgAttributes.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/engines/attributes/SVGAttributes.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/browserFeatureSupport.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imageTransformParts.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imageTransformOptions.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/transform.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/engines/transforms.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/uri.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/helpers/imagePlaceholderUtils.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/max/api.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/srcset.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/engines/attributes.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/uri/index.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/sdk/api.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/sdk/index.js","webpack:///../../../node_modules/@wix/image-kit/dist/esm/api/max/index.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imageServiceConstants.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imageServiceFeatureSupportObject.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/populateFeatureSupport.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/utils.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imageServiceUtils.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/engines/attributes/backgroundAttributes.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/engines/attributes/imgAttributes.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/engines/attributes/SVGAttributes.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/browserFeatureSupport.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imageTransformParts.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imageTransformOptions.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/api/transform.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/engines/transforms.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/api/uri.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/helpers/imagePlaceholderUtils.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/api/max/api.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/api/srcset.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/engines/attributes.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/sdk/api.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/sdk/index.js","webpack:///../../../node_modules/@wix/image/node_modules/@wix/image-kit/dist/esm/api/max/index.js"],"sourcesContent":["/**\n * image service api version\n */\nconst API_VERSION = 'v1';\n/**\nthe maximum retina factor\n */\nconst MAX_DEVICE_PIXEL_RATIO = 2;\n/**\n site BG legacy max width x height\n */\nconst DSKTP_MAX_BG_SITE_LEGACY_WIDTH = 1920;\nconst DSKTP_MAX_BG_SITE_LEGACY_HEIGHT = 1920;\nconst MOBILE_MAX_BG_SITE_LEGACY_WIDTH = 1000;\nconst MOBILE_MAX_BG_SITE_LEGACY_HEIGHT = 1000;\n/**\n * Enum string values of requested image fitting types\n * Note: TILE_HORIZONTAL, TILE_VERTICAL, FIT_AND_TILE are supported for legacy purposes but are not exposed\n * in the documentation because they should not be exposed for new features\n */\nconst fittingTypes = {\n    SCALE_TO_FILL: 'fill',\n    SCALE_TO_FIT: 'fit',\n    STRETCH: 'stretch',\n    ORIGINAL_SIZE: 'original_size',\n    TILE: 'tile',\n    TILE_HORIZONTAL: 'tile_horizontal',\n    TILE_VERTICAL: 'tile_vertical',\n    FIT_AND_TILE: 'fit_and_tile',\n    LEGACY_STRIP_TILE: 'legacy_strip_tile',\n    LEGACY_STRIP_TILE_HORIZONTAL: 'legacy_strip_tile_horizontal',\n    LEGACY_STRIP_TILE_VERTICAL: 'legacy_strip_tile_vertical',\n    LEGACY_STRIP_SCALE_TO_FILL: 'legacy_strip_fill',\n    LEGACY_STRIP_SCALE_TO_FIT: 'legacy_strip_fit',\n    LEGACY_STRIP_FIT_AND_TILE: 'legacy_strip_fit_and_tile',\n    LEGACY_STRIP_ORIGINAL_SIZE: 'legacy_strip_original_size',\n    LEGACY_ORIGINAL_SIZE: 'actual_size',\n    LEGACY_FIT_WIDTH: 'fitWidth',\n    LEGACY_FIT_HEIGHT: 'fitHeight',\n    LEGACY_FULL: 'full',\n    LEGACY_BG_FIT_AND_TILE: 'legacy_tile',\n    LEGACY_BG_FIT_AND_TILE_HORIZONTAL: 'legacy_tile_horizontal',\n    LEGACY_BG_FIT_AND_TILE_VERTICAL: 'legacy_tile_vertical',\n    LEGACY_BG_NORMAL: 'legacy_normal',\n};\n/**\n * Enum string values of image transform types as passed to the image service api\n */\nconst transformTypes = {\n    FIT: 'fit',\n    FILL: 'fill',\n    FILL_FOCAL: 'fill_focal',\n    CROP: 'crop',\n    LEGACY_CROP: 'legacy_crop',\n    LEGACY_FILL: 'legacy_fill',\n};\n/**\n * Enum string values of requested image align types\n * @type {{CENTER: string, RIGHT: string, LEFT: string, TOP: string, BOTTOM: string, TOP_RIGHT: string, TOP_LEFT: string, BOTTOM_RIGHT: string, BOTTOM_LEFT: string}}\n */\nconst alignTypes = {\n    CENTER: 'center',\n    TOP: 'top',\n    TOP_LEFT: 'top_left',\n    TOP_RIGHT: 'top_right',\n    BOTTOM: 'bottom',\n    BOTTOM_LEFT: 'bottom_left',\n    BOTTOM_RIGHT: 'bottom_right',\n    LEFT: 'left',\n    RIGHT: 'right',\n};\n/**\n * Enum 9Grid alignment to focal point\n */\nconst ALIGN_TYPE_TO_FOCAL_POINT = {\n    [alignTypes.CENTER]: { x: 0.5, y: 0.5 },\n    [alignTypes.TOP_LEFT]: { x: 0, y: 0 },\n    [alignTypes.TOP_RIGHT]: { x: 1.0, y: 0.5 },\n    [alignTypes.TOP]: { x: 0.5, y: 0 },\n    [alignTypes.BOTTOM_LEFT]: { x: 0, y: 1.0 },\n    [alignTypes.BOTTOM_RIGHT]: { x: 1.0, y: 1.0 },\n    [alignTypes.BOTTOM]: { x: 0.5, y: 1.0 },\n    [alignTypes.RIGHT]: { x: 1.0, y: 0.5 },\n    [alignTypes.LEFT]: { x: 0, y: 0.5 },\n};\n/**\n * Enum string values of image align types as passed to the image service\n */\nconst alignTypesMap = {\n    center: 'c',\n    top: 't',\n    top_left: 'tl',\n    top_right: 'tr',\n    bottom: 'b',\n    bottom_left: 'bl',\n    bottom_right: 'br',\n    left: 'l',\n    right: 'r',\n};\n/**\n * Enum string values of html tag used to construct the css or svg attributes\n *  @type {{BG: string, IMG: string, SVG: string}}\n */\nconst htmlTag = {\n    BG: 'bg',\n    IMG: 'img',\n    SVG: 'svg',\n};\n/**\n * Enum string values of upscale method\n *  @type {{DEFAULT: string, SUPER: string}}\n */\nconst upscaleMethods = {\n    AUTO: 'auto',\n    CLASSIC: 'classic',\n    SUPER: 'super',\n};\n/**\n *  api values of upscale method\n *  @type {{default: number, super: number}}\n */\nconst upscaleMethodsValues = {\n    classic: 1,\n    super: 2,\n};\n/**\n * default unsharp mask values\n *  @type {{radius: number, amount: number, threshold: number}}\n */\nconst defaultUSM = {\n    radius: '0.66',\n    amount: '1.00',\n    threshold: '0.01',\n};\n/**\n * default empty data\n */\nconst emptyData = {\n    uri: '',\n    css: {\n        img: {},\n        container: {},\n    },\n    attr: {\n        img: {},\n        container: {},\n    },\n    transformed: false,\n};\nconst MAX_TRANSFORMED_IMAGE_WIDTH = 5000;\nconst MAX_TRANSFORMED_IMAGE_HEIGHT = 5000;\nconst SAFE_TRANSFORMED_AREA = MAX_TRANSFORMED_IMAGE_WIDTH * MAX_TRANSFORMED_IMAGE_HEIGHT;\n/**\n * super res machine learning upscale factor models -\n * @type {number[]}\n */\nconst SUPER_UPSCALE_MODELS = [1.5, 2, 4];\n/**\n * image qualities\n */\nconst imageScaleDefaults = {\n    HIGH: {\n        size: 1400 * 1400,\n        quality: 90,\n        maxUpscale: 1,\n    },\n    MEDIUM: {\n        size: 600 * 600,\n        quality: 85,\n        maxUpscale: 1,\n    },\n    LOW: {\n        size: 400 * 400,\n        quality: 80,\n        maxUpscale: 1.2,\n    },\n    TINY: {\n        size: 0,\n        quality: 80,\n        maxUpscale: 1.4,\n    },\n};\n/**\n * image quality\n * @type {{HIGH: string, MEDIUM: string, LOW: string, TINY: string}}\n */\nconst imageQuality = {\n    HIGH: 'HIGH',\n    MEDIUM: 'MEDIUM',\n    LOW: 'LOW',\n    TINY: 'TINY',\n};\n/**\n * image filters\n * @type {{CONTRAST: string, BRIGHTNESS: string, SATURATION: string, HUE: string, BLUR: string}}\n */\nconst imageFilters = {\n    CONTRAST: 'contrast',\n    BRIGHTNESS: 'brightness',\n    SATURATION: 'saturation',\n    HUE: 'hue',\n    BLUR: 'blur',\n};\nconst fileType = {\n    JPG: 'jpg',\n    JPEG: 'jpeg',\n    JPE: 'jpe',\n    PNG: 'png',\n    WEBP: 'webp',\n    WIX_ICO_MP: 'wix_ico_mp',\n    WIX_MP: 'wix_mp',\n    GIF: 'gif',\n    SVG: 'svg',\n    UNRECOGNIZED: 'unrecognized',\n};\nconst supportedExtensions = [\n    fileType.JPG,\n    fileType.JPEG,\n    fileType.JPE,\n    fileType.PNG,\n    fileType.GIF,\n    fileType.WEBP,\n];\nexport { alignTypes, alignTypesMap, transformTypes, fittingTypes, htmlTag, upscaleMethods, upscaleMethodsValues, defaultUSM, emptyData, imageQuality, imageFilters, imageScaleDefaults, fileType, supportedExtensions, DSKTP_MAX_BG_SITE_LEGACY_WIDTH, MOBILE_MAX_BG_SITE_LEGACY_WIDTH, DSKTP_MAX_BG_SITE_LEGACY_HEIGHT, MOBILE_MAX_BG_SITE_LEGACY_HEIGHT, SAFE_TRANSFORMED_AREA, SUPER_UPSCALE_MODELS, MAX_DEVICE_PIXEL_RATIO, ALIGN_TYPE_TO_FOCAL_POINT, API_VERSION, };\n//# sourceMappingURL=imageServiceConstants.js.map","const globalFeaturesSupportObj = {\n    /**\n     * @type {object<boolean>}\n     */\n    isMobile: false,\n};\nconst getFeature = function (feature) {\n    return globalFeaturesSupportObj[feature];\n};\nconst setFeature = function (feature, value) {\n    globalFeaturesSupportObj[feature] = value;\n};\nexport { getFeature, setFeature };\n//# sourceMappingURL=imageServiceFeatureSupportObject.js.map","import { setFeature } from './imageServiceFeatureSupportObject';\n/**\n * Populate the global feature support object with browser specific values\n */\nfunction populateGlobalFeatureSupport() {\n    if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n        const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;\n        const isMobileAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        // set is mobile\n        setFeature('isMobile', isSmallScreen && isMobileAgent);\n    }\n}\nexport { populateGlobalFeatureSupport };\n//# sourceMappingURL=populateFeatureSupport.js.map","/**\n * Simple templates.\n * Receives a string with es6 ${...} style template arguments and returns a transformed string.\n * @param string\n * @returns {Function}\n */\nfunction template(strings, ...keys) {\n    return function (...values) {\n        const dict = values[values.length - 1] || {};\n        const result = [strings[0]];\n        keys.forEach(function (key, i) {\n            const value = Number.isInteger(key) ? values[key] : dict[key];\n            result.push(value, strings[i + 1]);\n        });\n        return result.join('');\n    };\n}\n/**\n * Get the last element in an array\n * @param array\n * @returns {*}\n */\nfunction last(array) {\n    return array[array.length - 1];\n}\nexport { last, template };\n//# sourceMappingURL=utils.js.map","import { alignTypes, alignTypesMap, fileType, fittingTypes, imageQuality, imageScaleDefaults, transformTypes, upscaleMethods, upscaleMethodsValues, ALIGN_TYPE_TO_FOCAL_POINT, MAX_DEVICE_PIXEL_RATIO, SUPER_UPSCALE_MODELS, SAFE_TRANSFORMED_AREA, } from './imageServiceConstants';\nimport { last } from './utils';\nconst SUPPORTED_IMAGE_EXTENSIONS = [\n    fileType.PNG,\n    fileType.JPEG,\n    fileType.JPG,\n    fileType.JPE,\n    fileType.WIX_ICO_MP,\n    fileType.WIX_MP,\n];\nconst JPG_EXTENSIONS = [\n    fileType.JPEG,\n    fileType.JPG,\n    fileType.JPE,\n];\n/**\n * checks if image type is supported\n * @param {string}     uri      image source uri\n *\n * @returns {boolean}\n */\nfunction isImageTypeSupported(uri) {\n    return SUPPORTED_IMAGE_EXTENSIONS.includes(getFileExtension(uri));\n}\n/**\n * check request integrity\n * @param {FittingType}             fittingType         imageService.fittingTypes\n * @param {ImageTransformSource}    src\n * @param {ImageTransformTarget}    target\n *\n * @returns {boolean}\n */\nfunction isValidRequest(fittingType, src, target) {\n    return (target &&\n        src &&\n        !isUrlEmptyOrNone(src.id) &&\n        Object.values(fittingTypes).includes(fittingType));\n}\n/**\n * check if image transform is supported for source image\n * @param {string}     uri\n *\n * @returns {boolean}\n */\nfunction isImageTransformApplicable(uri) {\n    return isImageTypeSupported(uri) && !isExternalUrl(uri);\n}\n/**\n * returns true if image is of JPG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isJPG(uri) {\n    return JPG_EXTENSIONS.includes(getFileExtension(uri));\n}\n/**\n * returns true if image is of PNG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isPNG(uri) {\n    return getFileExtension(uri) === fileType.PNG;\n}\n/**\n * returns true if image is of webP type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isWEBP(uri) {\n    return getFileExtension(uri) === fileType.WEBP;\n}\n/**\n * returns true if the url starts with http, https, // or data\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isExternalUrl(url) {\n    return /(^https?)|(^data)|(^\\/\\/)/.test(url);\n}\n/**\n * returns true if the url empty or none string\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isUrlEmptyOrNone(url) {\n    return !url || !url.trim() || url.toLowerCase() === 'none';\n}\n/**\n * returns search bot true or false as indicated in options\n * @param {ImageTransformOptions}   options\n *\n * @returns {boolean}\n */\nfunction isSEOBot(options) {\n    var _a;\n    return (_a = options === null || options === void 0 ? void 0 : options.isSEOBot) !== null && _a !== void 0 ? _a : false;\n}\n// https://jira.wixpress.com/browse/WEED-12667\n// const illegalChars = ['/', '\\\\', '#', '^', '?', '{', '}', '<', '>', '|', '`', '', ':', '\"'].map(encodeURIComponent)\nconst ILLEGAL_CHARS = ['/', '\\\\', '?', '<', '>', '|', '', ':', '\"'].map(encodeURIComponent);\nconst URL_SAFE_ILLEGAL_CHARS = ['\\\\.', '\\\\*'];\nconst ILLEGAL_CHARS_REPLACEMENT = '_';\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n * @param {string}     [name]   optional image source name\n *\n * @returns {string}\n */\nfunction getFileName(uri, name) {\n    const beforeLeadingSlashRegexp = /\\/(.*?)$/;\n    const fileExtensionRegexp = /\\.([^.]*)$/;\n    const illegalCharsRegex = new RegExp(`(${ILLEGAL_CHARS.concat(URL_SAFE_ILLEGAL_CHARS).join('|')})`, 'g');\n    // if name is a non empty string, remove only supported extension if exists and url encode the string\n    if (name && name.length) {\n        let fileName = name;\n        const extension = name.match(fileExtensionRegexp);\n        if (extension &&\n            SUPPORTED_IMAGE_EXTENSIONS.includes(extension[1])) {\n            fileName = name.replace(fileExtensionRegexp, '');\n        }\n        return encodeURIComponent(fileName).replace(illegalCharsRegex, ILLEGAL_CHARS_REPLACEMENT);\n    }\n    // else, trim any preceding media structure from the uri string (like \"media/\" etc.) and remove extension\n    const trimmed = uri.match(beforeLeadingSlashRegexp);\n    const fileName = trimmed ? trimmed[1] : uri;\n    return fileName.replace(fileExtensionRegexp, '');\n}\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n *\n * @returns {FileType}\n */\nfunction getFileType(uri) {\n    if (isJPG(uri)) {\n        return fileType.JPG;\n    }\n    else if (isPNG(uri)) {\n        return fileType.PNG;\n    }\n    else if (isWEBP(uri)) {\n        return fileType.WEBP;\n    }\n    return fileType.UNRECOGNIZED;\n}\n/**\n * returns source image file extension\n * @param {string}     uri      image source uri\n *\n * @returns {string}\n */\nfunction getFileExtension(uri) {\n    const splitURI = /[.]([^.]+)$/.exec(uri);\n    return ((splitURI && /[.]([^.]+)$/.exec(uri)[1]) || '').toLowerCase();\n}\n/**\n * returns scale factor needed if FIT fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFitScaleFactor(sWidth, sHeight, dWidth, dHeight) {\n    return Math.min(dWidth / sWidth, dHeight / sHeight);\n}\n/**\n * returns scale factor needed if FILL fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFillScaleFactor(sWidth, sHeight, dWidth, dHeight) {\n    return Math.max(dWidth / sWidth, dHeight / sHeight);\n}\n/**\n * returns scale factor source target\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n * @param {string}  transformType\n *\n * @returns {number}\n */\nfunction getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType) {\n    let scaleFactor;\n    if (transformType === transformTypes.FILL) {\n        scaleFactor = getFillScaleFactor(sWidth, sHeight, dWidth, dHeight);\n    }\n    else if (transformType === transformTypes.FIT) {\n        scaleFactor = getFitScaleFactor(sWidth, sHeight, dWidth, dHeight);\n    }\n    else {\n        scaleFactor = 1;\n    }\n    return scaleFactor;\n}\n/**\n * get calculated scale factor , width and height while considering wixmp image transform dimension limits\n * @param sWidth\n * @param sHeight\n * @param dWidth\n * @param dHeight\n * @param transformType\n * @returns {{scaleFactor: *, width: *, height: *}}\n */\nfunction getSafeTransformData(sWidth, sHeight, dWidth, dHeight, transformType) {\n    let scaleFactor;\n    // defaults for FILL transform type\n    let width = dWidth;\n    let height = dHeight;\n    // calculate safe image transformed area\n    scaleFactor = getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType);\n    if (transformType === transformTypes.FIT) {\n        width = sWidth * scaleFactor;\n        height = sHeight * scaleFactor;\n    }\n    // adjust target width & height & scaleFactor\n    if (width && height && width * height > SAFE_TRANSFORMED_AREA) {\n        const dimensionScaleFactor = Math.sqrt(SAFE_TRANSFORMED_AREA / (width * height));\n        width *= dimensionScaleFactor;\n        height *= dimensionScaleFactor;\n        // get the new scale factor\n        scaleFactor = getScaleFactor(sWidth, sHeight, width, height, transformType);\n    }\n    return {\n        scaleFactor,\n        width,\n        height,\n    };\n}\n/**\n * returns the destination rectangle\n * @param {number}                  sWidth\n * @param {number}                  sHeight\n * @param {TransformType}           transformType\n * @param {ImageTransformTarget}    target\n * @param {number}                  dpr - device pixel ratio\n * @param {UpscaleMethod}           upscaleMethod\n *\n * @returns {ImageTransformData & {upscaleMethodValue: number}}\n */\nfunction getTransformData(sWidth, sHeight, transformType, target, dpr, upscaleMethod) {\n    // use target dimension is src not provided\n    sWidth = sWidth || target.width;\n    sHeight = sHeight || target.height;\n    // adjust image transform values considering server side transform limitations and performance\n    const { scaleFactor, width, height } = getSafeTransformData(sWidth, sHeight, target.width * dpr, target.height * dpr, transformType);\n    // adjust image transform values to optimizing upsacle quality and payload\n    return getOptimizedTransformData(sWidth, sHeight, width, height, upscaleMethod, scaleFactor, transformType);\n}\n/**\n * converts 9 grid alignment to Focal point position\n * @param {string}  [alignment]\n *\n * @returns {x:number,y:number}\n */\nfunction getFocalPointFrom9GridAlignment(alignment = alignTypes.CENTER) {\n    return ALIGN_TYPE_TO_FOCAL_POINT[alignment];\n}\n/**\n * returns overlapping rectangle where sRect\n * id aligned (according to alignment) within dRect\n * @param {{ width: number; height: number }} sRect rect 1\n * @param {{ width: number, height: number }} dRect rect 2\n * @param {{x: number, y: number}|undefined}  sFP   source image focal point\n * @param {string}                            alignment\n *\n * @returns {{x: number, y: number, width: number, height: number}}\n */\nfunction getAlignedRect(sRect, dRect, sFP, alignment) {\n    const fp = getFocalPoint(sFP) ||\n        getFocalPointFrom9GridAlignment(alignment);\n    const x = Math.max(0, Math.min(sRect.width - dRect.width, fp.x * sRect.width - dRect.width / 2));\n    const y = Math.max(0, Math.min(sRect.height - dRect.height, fp.y * sRect.height - dRect.height / 2));\n    // rect\n    return {\n        x,\n        y,\n        width: Math.min(sRect.width, dRect.width),\n        height: Math.min(sRect.height, dRect.height),\n    };\n}\n/**\n * returns overlapping rectangle between sRect and dRect\n * @param {object}      sRect         rect 1\n * @param {object}      dRect         rect 2\n *\n * @returns {{x:number,y:number,width:number, height:number} || null}\n */\nfunction getOverlappingRect(sRect, dRect) {\n    const width = Math.max(0, Math.min(sRect.width, dRect.x + dRect.width) - Math.max(0, dRect.x));\n    const height = Math.max(0, Math.min(sRect.height, dRect.y + dRect.height) - Math.max(0, dRect.y));\n    const isValidRect = width && height && (sRect.width !== width || sRect.height !== height);\n    // return overlapping sRect/dRect rectangle(x, y, width, height)\n    return isValidRect\n        ? {\n            x: Math.max(0, dRect.x),\n            y: Math.max(0, dRect.y),\n            width,\n            height,\n        }\n        : null;\n}\n/**\n * returns pixel aspect ratio value\n * @param {ImageTransformTarget}    target\n *\n * @returns {number}\n */\nfunction getDevicePixelRatio(target) {\n    return Math.min(target.pixelAspectRatio || 1, MAX_DEVICE_PIXEL_RATIO);\n}\n/**\n * returns target alignment value\n * @param {ImageTransformTarget}    target\n *\n * @returns {string}\n */\nfunction getAlignment(target) {\n    return ((target.alignment && alignTypesMap[target.alignment]) ||\n        alignTypesMap[alignTypes.CENTER]);\n}\n/**\n * returns the focal point value, if no focal point passed use alignment\n * @param {{x: number, y: number}|undefined} focalPoint\n */\nfunction getFocalPoint(focalPoint) {\n    let fp;\n    if (focalPoint &&\n        typeof focalPoint.x === 'number' &&\n        !isNaN(focalPoint.x) &&\n        typeof focalPoint.y === 'number' &&\n        !isNaN(focalPoint.y)) {\n        fp = {\n            x: roundToFixed(Math.max(0, Math.min(100, focalPoint.x)) / 100, 2),\n            y: roundToFixed(Math.max(0, Math.min(100, focalPoint.y)) / 100, 2),\n        };\n    }\n    return fp;\n}\n/**\n * returns preferred image quality value\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {number}\n */\nfunction getPreferredImageQuality(imageWidth, imageHeight) {\n    return imageScaleDefaults[getImageQualityKey(imageWidth, imageHeight)]\n        .quality;\n}\n/**\n * returns the scale descriptor of CLASSIC upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getClassicScaleData(sWidth, sHeight) {\n    const imageKey = getImageQualityKey(sWidth, sHeight);\n    return {\n        optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n        upscaleMethodValue: upscaleMethodsValues.classic,\n        forceUSM: false,\n    };\n}\n/**\n * returns the scale descriptor of AUTO upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getAutoScaleData(sWidth, sHeight) {\n    const imageKey = getImageQualityKey(sWidth, sHeight);\n    return {\n        optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n        upscaleMethodValue: upscaleMethodsValues.classic,\n        forceUSM: false,\n    };\n}\n/**\n * returns the scale descriptor of SUPER upscale method\n * @param scaleFactor\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getSuperScaleData(scaleFactor) {\n    return {\n        optimizedScaleFactor: last(SUPER_UPSCALE_MODELS),\n        upscaleMethodValue: upscaleMethodsValues.super,\n        forceUSM: !(SUPER_UPSCALE_MODELS.includes(scaleFactor) ||\n            scaleFactor > last(SUPER_UPSCALE_MODELS)),\n    };\n}\n/**\n * returns upscale descriptor object\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {string}    upscaleMethod\n * @param {number}    scaleFactor\n *\n * @returns  {{maxScale: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod) {\n    if (upscaleMethod === 'auto') {\n        return getAutoScaleData(sWidth, sHeight);\n    }\n    else if (upscaleMethod === 'super') {\n        return getSuperScaleData(scaleFactor);\n    }\n    // assuming 'classic' method\n    return getClassicScaleData(sWidth, sHeight);\n}\n/**\n * returns optimized upscale data, considering requested upscale method , optimize upscale for best quality and bandwidth\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {number}    tWidth\n * @param {number}    tHeight\n * @param {UpscaleMethod}    upscaleMethod\n * @param {number}    scaleFactor\n * @param {TransformType}    transformType\n *\n * @returns  {ImageTransformData}\n */\nfunction getOptimizedTransformData(sWidth, sHeight, tWidth, tHeight, upscaleMethod, scaleFactor, transformType) {\n    const { optimizedScaleFactor, upscaleMethodValue, forceUSM, } = getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod);\n    let width = tWidth;\n    let height = tHeight;\n    if (scaleFactor <= optimizedScaleFactor) {\n        // target upscale within limits or downscale\n        return {\n            width,\n            height,\n            scaleFactor,\n            upscaleMethodValue,\n            forceUSM,\n            cssUpscaleNeeded: false,\n        };\n    }\n    // limited upscale\n    switch (transformType) {\n        case transformTypes.FILL:\n            width = tWidth * (optimizedScaleFactor / scaleFactor);\n            height = tHeight * (optimizedScaleFactor / scaleFactor);\n            break;\n        case transformTypes.FIT:\n            width = sWidth * optimizedScaleFactor;\n            height = sHeight * optimizedScaleFactor;\n            break;\n        default:\n            break;\n    }\n    // adjust transform values\n    return {\n        width,\n        height,\n        scaleFactor: optimizedScaleFactor,\n        upscaleMethodValue,\n        forceUSM,\n        cssUpscaleNeeded: true,\n    };\n}\n/**\n * returns image quality key\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {ImageQuality}\n */\nfunction getImageQualityKey(imageWidth, imageHeight) {\n    const size = imageWidth * imageHeight;\n    if (size > imageScaleDefaults[imageQuality.HIGH].size) {\n        return imageQuality.HIGH;\n    }\n    else if (size > imageScaleDefaults[imageQuality.MEDIUM].size) {\n        return imageQuality.MEDIUM;\n    }\n    else if (size > imageScaleDefaults[imageQuality.LOW].size) {\n        return imageQuality.LOW;\n    }\n    return imageQuality.TINY;\n}\n/**\n * return the actual rounded dimension of a scaled rectangle\n * @param sWidth\n * @param sHeight\n * @param tWidth\n * @param tHeight\n * @param transformType\n * @returns {{width: number, height: number}}\n */\nfunction getDimension(sWidth, sHeight, tWidth, tHeight, transformType) {\n    const scaleFactor = getScaleFactor(sWidth, sHeight, tWidth, tHeight, transformType);\n    return {\n        width: Math.round(sWidth * scaleFactor),\n        height: Math.round(sHeight * scaleFactor),\n    };\n}\n/**\n * rounds number n digit precision and converts to string\n * @param {number}      value\n * @param {number}      precision\n *\n * @returns {string}\n */\nfunction roundToFixed(value, precision) {\n    const truncatePrecision = Math.pow(10, precision || 0);\n    return ((value * truncatePrecision) / truncatePrecision).toFixed(precision);\n}\n/**\n * get normalize scale method\n * @param {ImageTransformOptions} [options]\n * @returns {UpscaleMethod}\n */\nfunction getUpscaleString(options) {\n    if (!options || !options.upscaleMethod) {\n        return upscaleMethods.AUTO;\n    }\n    return (upscaleMethods[options.upscaleMethod.toUpperCase()] || upscaleMethods.AUTO);\n}\nexport { getAlignedRect, getAlignment, getDevicePixelRatio, getDimension, getFileExtension, getFileName, getFileType, getFocalPoint, getOverlappingRect, getPreferredImageQuality, getScaleFactor, getTransformData, getUpscaleString, isExternalUrl, isImageTransformApplicable, isImageTypeSupported, isSEOBot, isValidRequest, isPNG, isWEBP, roundToFixed, };\n//# sourceMappingURL=imageServiceUtils.js.map","import { alignTypes, fittingTypes } from '../../helpers/imageServiceConstants';\n/**\n * returns BG tag CSS data\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns {BackgroundImageAttributes}\n */\nfunction getCSS(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n        },\n    };\n    const { css } = attributes;\n    const { fittingType } = transformsObj;\n    // set fitting\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:\n            css.container.backgroundSize = 'contain';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.STRETCH:\n            css.container.backgroundSize = '100% 100%';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:\n            css.container.backgroundSize = 'cover';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-x';\n            break;\n        case fittingTypes.TILE_VERTICAL:\n        case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-y';\n            break;\n        case fittingTypes.TILE:\n        case fittingTypes.LEGACY_STRIP_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:\n            css.container.backgroundSize = 'contain';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.FIT_AND_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        // Legacy old editor bg types.\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-x';\n            break;\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-y';\n            break;\n        case fittingTypes.LEGACY_BG_NORMAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n    }\n    // set alignment\n    switch (target.alignment) {\n        case alignTypes.CENTER:\n            css.container.backgroundPosition = 'center center'; // 50% 50%\n            break;\n        case alignTypes.LEFT:\n            css.container.backgroundPosition = 'left center'; // 0% 50%\n            break;\n        case alignTypes.RIGHT:\n            css.container.backgroundPosition = 'right center'; // 100% 50%\n            break;\n        case alignTypes.TOP:\n            css.container.backgroundPosition = 'center top'; // 50% 0%\n            break;\n        case alignTypes.BOTTOM:\n            css.container.backgroundPosition = 'center bottom'; // 50% 100%\n            break;\n        case alignTypes.TOP_RIGHT:\n            css.container.backgroundPosition = 'right top'; // 100% 0%\n            break;\n        case alignTypes.TOP_LEFT:\n            css.container.backgroundPosition = 'left top'; // 0% 0%\n            break;\n        case alignTypes.BOTTOM_RIGHT:\n            css.container.backgroundPosition = 'right bottom'; // 100% 100%\n            break;\n        case alignTypes.BOTTOM_LEFT:\n            css.container.backgroundPosition = 'left bottom'; // 0% 100%\n            break;\n    }\n    // return background CSS\n    return attributes;\n}\nexport { getCSS as get };\n//# sourceMappingURL=backgroundAttributes.js.map","import { alignTypes, fittingTypes } from '../../helpers/imageServiceConstants';\n/**\n * align type to position\n * @param verticalMiddle\n * @param horizontalMiddle\n * @param target\n * @returns {{}}\n */\nfunction alignTypeToPosition(verticalMiddle, horizontalMiddle, target) {\n    return {\n        [alignTypes.TOP_LEFT]: { top: 0, left: 0 },\n        [alignTypes.TOP_RIGHT]: { top: 0, right: 0 },\n        [alignTypes.TOP]: { top: 0, left: horizontalMiddle },\n        [alignTypes.BOTTOM_LEFT]: { bottom: 0, left: 0 },\n        [alignTypes.BOTTOM_RIGHT]: { bottom: 0, right: 0 },\n        [alignTypes.BOTTOM]: { bottom: 0, left: horizontalMiddle },\n        [alignTypes.RIGHT]: { top: verticalMiddle, right: 0 },\n        [alignTypes.LEFT]: { top: verticalMiddle, left: 0 },\n        [alignTypes.CENTER]: {\n            width: target.width,\n            height: target.height,\n            objectFit: 'none',\n        },\n    };\n}\nconst alignTypeToPositionStr = {\n    [alignTypes.CENTER]: 'center',\n    [alignTypes.TOP]: 'top',\n    [alignTypes.TOP_LEFT]: 'top left',\n    [alignTypes.TOP_RIGHT]: 'top right',\n    [alignTypes.BOTTOM]: 'bottom',\n    [alignTypes.BOTTOM_LEFT]: 'bottom left',\n    [alignTypes.BOTTOM_RIGHT]: 'bottom right',\n    [alignTypes.LEFT]: 'left',\n    [alignTypes.RIGHT]: 'right',\n};\nconst aligmentDefaults = {\n    position: 'absolute',\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto',\n};\n/**\n * returns image tag CSS data\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns {ImageAttributes}\n */\nfunction getCSS(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n            img: {},\n        },\n    };\n    const { css } = attributes;\n    const { fittingType } = transformsObj;\n    const alignType = target.alignment;\n    css.container.position = 'relative';\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n            if (transformsObj.parts && transformsObj.parts.length) {\n                css.img.width = transformsObj.parts[0].width;\n                css.img.height = transformsObj.parts[0].height;\n            }\n            else {\n                css.img.width = transformsObj.src.width;\n                css.img.height = transformsObj.src.height;\n            }\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'contain';\n            css.img.objectPosition =\n                alignTypeToPositionStr[alignType] || 'unset';\n            break;\n        // BG_NORMAL is a sitebackground legacy for original size fitting type.\n        // target width and height were modified in transform.js\n        case fittingTypes.LEGACY_BG_NORMAL:\n            css.img.width = '100%';\n            css.img.height = '100%';\n            css.img.objectFit = 'none';\n            css.img.objectPosition =\n                alignTypeToPositionStr[alignType] || 'unset';\n            break;\n        case fittingTypes.STRETCH:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'fill';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'cover';\n            break;\n    }\n    // set alignment in a private case where the image src is smaller than the image container,\n    if (typeof css.img.width === 'number' &&\n        typeof css.img.height === 'number' &&\n        (css.img.width !== target.width || css.img.height !== target.height)) {\n        const verticalMiddle = Math.round((target.height - css.img.height) / 2);\n        const horizontalMiddle = Math.round((target.width - css.img.width) / 2);\n        Object.assign(css.img, aligmentDefaults, alignTypeToPosition(verticalMiddle, horizontalMiddle, target)[alignType]);\n    }\n    return attributes;\n}\nexport { getCSS as get };\n//# sourceMappingURL=imgAttributes.js.map","import { fittingTypes, alignTypes, transformTypes, } from '../../helpers/imageServiceConstants';\nimport { getDimension, isImageTransformApplicable, } from '../../helpers/imageServiceUtils';\n/* eslint-disable indent */\n/**\n * get CSS or SVG attributes to be used in the browser\n * @param {ImageTransformObject}  transformsObj  transform parts object\n * @param {ImageTransformTarget}  target\n *\n * @returns {SVGImageAttributes}\n */\nfunction getSvgAttr(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n        },\n        attr: {\n            container: {},\n            img: {},\n        },\n    };\n    const { css, attr } = attributes;\n    const { fittingType } = transformsObj;\n    const alignType = target.alignment;\n    const { width: sourceWidth, height: sourceHeight } = transformsObj.src;\n    let imageScale;\n    css.container.position = 'relative';\n    // populate SVG attributes object\n    // eslint-disable-line indent\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.TILE:\n            if (transformsObj.parts && transformsObj.parts.length) {\n                attr.img.width = transformsObj.parts[0].width;\n                attr.img.height = transformsObj.parts[0].height;\n            }\n            else {\n                attr.img.width = sourceWidth;\n                attr.img.height = sourceHeight;\n            }\n            attr.img.preserveAspectRatio = 'xMidYMid slice';\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n            attr.img.width = '100%';\n            attr.img.height = '100%';\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = '';\n            break;\n        case fittingTypes.STRETCH:\n            attr.img.width = target.width;\n            attr.img.height = target.height;\n            attr.img.x = 0;\n            attr.img.y = 0;\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = 'none';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            if (!isImageTransformApplicable(transformsObj.src.id)) {\n                imageScale = getDimension(sourceWidth, sourceHeight, target.width, target.height, transformTypes.FILL);\n                attr.img.width = imageScale.width;\n                attr.img.height = imageScale.height;\n            }\n            else {\n                attr.img.width = target.width;\n                attr.img.height = target.height;\n            }\n            attr.img.x = 0;\n            attr.img.y = 0;\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = 'xMidYMid slice';\n            break;\n    }\n    // set alignment for cases where the requested src is smaller or bigger than the target element,\n    if (typeof attr.img.width === 'number' &&\n        typeof attr.img.height === 'number' &&\n        (attr.img.width !== target.width || attr.img.height !== target.height)) {\n        // x and y to use in svg <pattern> element\n        let x = 0;\n        let y = 0;\n        let right;\n        let bottom;\n        if (fittingType === fittingTypes.TILE) {\n            right = target.width % attr.img.width;\n            bottom = target.height % attr.img.height;\n        }\n        else {\n            right = target.width - attr.img.width;\n            bottom = target.height - attr.img.height;\n        }\n        const center = Math.round(right / 2);\n        const middle = Math.round(bottom / 2);\n        switch (alignType) {\n            case alignTypes.TOP_LEFT:\n                x = 0;\n                y = 0;\n                break;\n            case alignTypes.TOP:\n                x = center;\n                y = 0;\n                break;\n            case alignTypes.TOP_RIGHT:\n                x = right;\n                y = 0;\n                break;\n            case alignTypes.LEFT:\n                x = 0;\n                y = middle;\n                break;\n            case alignTypes.CENTER:\n                x = center;\n                y = middle;\n                break;\n            case alignTypes.RIGHT:\n                x = right;\n                y = middle;\n                break;\n            case alignTypes.BOTTOM_LEFT:\n                x = 0;\n                y = bottom;\n                break;\n            case alignTypes.BOTTOM:\n                x = center;\n                y = bottom;\n                break;\n            case alignTypes.BOTTOM_RIGHT:\n                x = right;\n                y = bottom;\n                break;\n        }\n        attr.img.x = x;\n        attr.img.y = y;\n    }\n    attr.container.width = target.width;\n    attr.container.height = target.height;\n    attr.container.viewBox = [0, 0, target.width, target.height].join(' ');\n    // return attributes object\n    return attributes;\n}\n/* eslint-enable indent */\nexport { getSvgAttr as get };\n//# sourceMappingURL=SVGAttributes.js.map","import { getFeature } from './imageServiceFeatureSupportObject';\n/**\n * get a browser detection if running on mobile device\n *\n * @returns {boolean}\n */\nfunction isMobile() {\n    return getFeature('isMobile');\n}\nexport { isMobile };\n//# sourceMappingURL=browserFeatureSupport.js.map","import { fittingTypes, transformTypes, alignTypesMap, } from './imageServiceConstants';\nimport { getAlignment, getScaleFactor, getOverlappingRect, getAlignedRect, getTransformData, getFocalPoint, } from './imageServiceUtils';\n/**\n * request analysis, returns parsed transforms object\n * @param {object}                  transformsObj\n * @param {ImageTransformSource}    src\n * @param {ImageTransformTarget}    target\n */\nfunction setTransformParts(transformsObj, src, target) {\n    let rect;\n    // crop source image if needed\n    // set crop part and adjust source dimensions\n    if (src.crop) {\n        rect = getOverlappingRect(src, src.crop);\n        if (rect) {\n            transformsObj.src.width = rect.width;\n            transformsObj.src.height = rect.height;\n            transformsObj.src.isCropped = true;\n            transformsObj.parts.push(getCropPart(rect));\n        }\n    }\n    // set additional transform part\n    switch (transformsObj.fittingType) {\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n        case fittingTypes.FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n        case fittingTypes.LEGACY_BG_NORMAL:\n            // fit\n            transformsObj.parts.push(getFitPart(transformsObj, target));\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            // fill\n            transformsObj.parts.push(getFillPart(transformsObj, target));\n            break;\n        case fittingTypes.STRETCH:\n            // stretch\n            transformsObj.parts.push(getStretchPart(transformsObj, target));\n            break;\n        case fittingTypes.TILE_HORIZONTAL:\n        case fittingTypes.TILE_VERTICAL:\n        case fittingTypes.TILE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.ORIGINAL_SIZE:\n            // use crop transform\n            // if crop of source image was requested adjust cropping rectangle\n            rect = getAlignedRect(transformsObj.src, target, transformsObj.focalPoint, target.alignment);\n            if (transformsObj.src.isCropped) {\n                Object.assign(transformsObj.parts[0], rect);\n                // update source width & height accordingly\n                transformsObj.src.width = rect.width;\n                transformsObj.src.height = rect.height;\n            }\n            else {\n                transformsObj.parts.push(getCropPart(rect));\n            }\n            break;\n        // ---------------------------------------------------------------------------------------\n        // handles a legacy bug on bgImageStrip, background html tag\n        // component Full Width Strip stored incorrect image source width and height\n        // ---------------------------------------------------------------------------------------\n        case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:\n        case fittingTypes.LEGACY_STRIP_TILE:\n        case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:\n            // crop request of source image is not supported\n            // use legacy crop\n            transformsObj.parts.push(getLegacyCropPart(target));\n            break;\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:\n        case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:\n            // legacy fit\n            transformsObj.parts.push(getLegacyFitPart(target));\n            break;\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:\n            // legacy fill\n            transformsObj.parts.push(getLegacyFillPart(target));\n            break;\n    }\n}\n/**\n * returns fit part of the image transform uri\n * @param {object}                  transformsObj\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformFitPart}\n */\nfunction getFitPart(transformsObj, target) {\n    // calculate the transformed image size needed\n    const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FIT, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);\n    const transformType = transformTypes.FILL;\n    // return fit transform data\n    return {\n        transformType,\n        width: Math.round(transformedData.width),\n        height: Math.round(transformedData.height),\n        alignment: alignTypesMap.center,\n        upscale: transformedData.scaleFactor > 1,\n        forceUSM: transformedData.forceUSM,\n        scaleFactor: transformedData.scaleFactor,\n        cssUpscaleNeeded: transformedData.cssUpscaleNeeded,\n        upscaleMethodValue: transformedData.upscaleMethodValue,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformObject} transformsObj\n * @param {ImageTransformTarget} target\n *\n * @returns {TransformFillPart}\n */\nfunction getFillPart(transformsObj, target) {\n    // calculate the transformed image size needed\n    const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FILL, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);\n    const focalPoint = getFocalPoint(transformsObj.focalPoint);\n    const transformType = focalPoint\n        ? transformTypes.FILL_FOCAL\n        : transformTypes.FILL;\n    return {\n        transformType,\n        width: Math.round(transformedData.width),\n        height: Math.round(transformedData.height),\n        alignment: getAlignment(target),\n        focalPointX: focalPoint && focalPoint.x,\n        focalPointY: focalPoint && focalPoint.y,\n        upscale: transformedData.scaleFactor > 1,\n        forceUSM: transformedData.forceUSM,\n        scaleFactor: transformedData.scaleFactor,\n        cssUpscaleNeeded: transformedData.cssUpscaleNeeded,\n        upscaleMethodValue: transformedData.upscaleMethodValue,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformObject} transformsObj\n * @param {ImageTransformTarget} target\n *\n * @returns {TransformFitPart}\n */\nfunction getStretchPart(transformsObj, target) {\n    // stretch data\n    const scaleFactor = getScaleFactor(transformsObj.src.width, transformsObj.src.height, target.width, target.height, transformTypes.FILL);\n    const clonedTarget = Object.assign({}, target);\n    clonedTarget.width = transformsObj.src.width * scaleFactor;\n    clonedTarget.height = transformsObj.src.height * scaleFactor;\n    // return stretch part\n    return getFitPart(transformsObj, clonedTarget);\n}\n/**\n * returns crop part of the image transform uri\n * @param {{x: number, y: number, width: number, height: number}}  rect     x, y, width, height\n *\n * @returns {TransformCropPart}\n */\nfunction getCropPart(rect) {\n    return {\n        transformType: transformTypes.CROP,\n        x: Math.round(rect.x),\n        y: Math.round(rect.y),\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n        upscale: false,\n        forceUSM: false,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n// ---------------------------------------------------------------------------------------\n// handles a legacy bug on bgImageStrip, background html tag\n// component Full Width Strip stored incorrect image source width and height\n// ---------------------------------------------------------------------------------------\n/**\n * returns fit part of the image transform uri\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformLegacyFitPart}\n */\nfunction getLegacyFitPart(target) {\n    return {\n        transformType: transformTypes.FIT,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        upscale: false,\n        forceUSM: true,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformLegacyFillPart}\n */\nfunction getLegacyFillPart(target) {\n    return {\n        transformType: transformTypes.LEGACY_FILL,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        alignment: getAlignment(target),\n        upscale: false,\n        forceUSM: true,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n/**\n * returns legacy crop part of the image transform uri\n * @param {ImageTransformTarget}     target\n *\n * @returns {TransformLegacyCropPart}\n */\nfunction getLegacyCropPart(target) {\n    return {\n        transformType: transformTypes.LEGACY_CROP,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        alignment: getAlignment(target),\n        upscale: false,\n        forceUSM: false,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\nexport { setTransformParts };\n//# sourceMappingURL=imageTransformParts.js.map","import { last } from './utils';\nimport { getPreferredImageQuality, roundToFixed } from './imageServiceUtils';\nimport { defaultUSM, fileType, imageFilters } from './imageServiceConstants';\n/**\n * returns image filters part of the image transform uri\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   [options]\n */\nfunction setTransformOptions(transformsObj, options) {\n    var _a;\n    options = options || {};\n    // options - general\n    transformsObj.quality = getQuality(transformsObj, options);\n    transformsObj.progressive = getProgressive(options);\n    transformsObj.watermark = getWatermark(options);\n    transformsObj.autoEncode = (_a = options.autoEncode) !== null && _a !== void 0 ? _a : true;\n    // options - filters & adjustments\n    transformsObj.unsharpMask = getUnsharpMask(transformsObj, options);\n    transformsObj.filters = getFilters(options);\n}\n/**\n *\n * @param {ImageTransformOptions}   options\n * @returns {string}\n */\nfunction getWatermark(options) {\n    return options.watermark;\n}\n/**\n * returns progressive if required\n * @param {ImageTransformOptions}   options\n *\n * @returns {boolean}\n */\nfunction getProgressive(options) {\n    return options.progressive !== false;\n}\n/**\n * returns image filters part of the image transform uri\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   options\n *\n * @returns {number}\n */\nfunction getQuality(transformsObj, options) {\n    const isPNG = transformsObj.fileType === fileType.PNG;\n    const isJPG = transformsObj.fileType === fileType.JPG;\n    const isQualitySupported = isJPG || isPNG;\n    if (isQualitySupported) {\n        const transformData = last(transformsObj.parts);\n        const defaultQuality = getPreferredImageQuality(transformData.width, transformData.height);\n        let quality = options.quality && options.quality >= 5 && options.quality <= 90\n            ? options.quality\n            : defaultQuality;\n        // increase quality by 5 for webp images\n        quality = isPNG ? quality + 5 : quality;\n        return quality;\n    }\n    // quality not supported\n    return 0;\n}\n/**\n * returns the desired transformed image filters\n * @param {ImageTransformOptions}   options\n *\n * @returns {object}\n */\nfunction getFilters(options) {\n    const filterOptions = options.filters || {};\n    const filters = {};\n    // contrast\n    if (isValidImageFilter(filterOptions[imageFilters.CONTRAST], -100, 100)) {\n        filters[imageFilters.CONTRAST] = filterOptions[imageFilters.CONTRAST];\n    }\n    // brightness\n    if (isValidImageFilter(filterOptions[imageFilters.BRIGHTNESS], -100, 100)) {\n        filters[imageFilters.BRIGHTNESS] = filterOptions[imageFilters.BRIGHTNESS];\n    }\n    // saturation\n    if (isValidImageFilter(filterOptions[imageFilters.SATURATION], -100, 100)) {\n        filters[imageFilters.SATURATION] = filterOptions[imageFilters.SATURATION];\n    }\n    // hue\n    if (isValidImageFilter(filterOptions[imageFilters.HUE], -180, 180)) {\n        filters[imageFilters.HUE] = filterOptions[imageFilters.HUE];\n    }\n    // blur\n    if (isValidImageFilter(filterOptions[imageFilters.BLUR], 0, 100)) {\n        filters[imageFilters.BLUR] = filterOptions[imageFilters.BLUR];\n    }\n    return filters;\n}\n/**\n * indicates if requested filter value is valid\n * @param {number|undefined}  filterValue     filter's value\n * @param {number}  minValue        min range\n * @param {number}  maxValue        max range\n *\n * @returns {boolean}\n */\nfunction isValidImageFilter(filterValue, minValue, maxValue) {\n    // check if filter name and filter values range valid\n    return (typeof filterValue === 'number' &&\n        !isNaN(filterValue) &&\n        filterValue !== 0 &&\n        filterValue >= minValue &&\n        filterValue <= maxValue);\n}\n/**\n * returns the desired transformed image unSharpMask values\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   options\n *\n * @returns {object}\n */\nfunction getUnsharpMask(transformsObj, options) {\n    var _a, _b, _c;\n    // If options.unsharpMask is a valid value, use it\n    if (isUSMValid(options.unsharpMask)) {\n        // If we got usm, change values to have trailing zeros (.00), else return undefined\n        return {\n            radius: roundToFixed((_a = options.unsharpMask) === null || _a === void 0 ? void 0 : _a.radius, 2),\n            amount: roundToFixed((_b = options.unsharpMask) === null || _b === void 0 ? void 0 : _b.amount, 2),\n            threshold: roundToFixed((_c = options.unsharpMask) === null || _c === void 0 ? void 0 : _c.threshold, 2),\n        };\n        // if options.unsharpMask is not all zeros and not valid and usm should be used, use default\n    }\n    else if (!isZeroUSM(options.unsharpMask) && isUSMNeeded(transformsObj)) {\n        return defaultUSM;\n    }\n    return;\n}\n/**\n * indicates if usm is needed\n * @param {ImageTransformObject}      transformsObj   transform parts object\n *\n * @returns {boolean}\n */\nfunction isUSMNeeded(transformsObj) {\n    // ---------------------------------------------------------------------------------------\n    // do not apply usm if transformed image width & height is same as source image or larger\n    // and no force usm is desired\n    // ---------------------------------------------------------------------------------------\n    const transformPart = last(transformsObj.parts);\n    const upscale = transformPart.scaleFactor >= 1;\n    // return if usm is needed\n    return !upscale || transformPart.forceUSM;\n}\n/**\n * indicates if all usm values are presented and in range\n * @param {OptionUnsharpMask|undefined}  usm     unsharp mask\n *\n * @returns {boolean}\n */\nfunction isUSMValid(usm) {\n    usm = usm || {};\n    const radius = typeof usm.radius === 'number' &&\n        !isNaN(usm.radius) &&\n        usm.radius >= 0.1 &&\n        usm.radius <= 500;\n    const amount = typeof usm.amount === 'number' &&\n        !isNaN(usm.amount) &&\n        usm.amount >= 0 &&\n        usm.amount <= 10;\n    const threshold = typeof usm.threshold === 'number' &&\n        !isNaN(usm.threshold) &&\n        usm.threshold >= 0 &&\n        usm.threshold <= 255;\n    // return is a valid USM data\n    return radius && amount && threshold;\n}\n/**\n * indicates if all usm values are presented and are zero. an explicit request to not apply usm\n * @param {OptionUnsharpMask|undefined}  usm     unsharp mask\n *\n * @returns {boolean}\n */\nfunction isZeroUSM(usm) {\n    usm = usm || {};\n    return (typeof usm.radius === 'number' &&\n        !isNaN(usm.radius) &&\n        usm.radius === 0 &&\n        typeof usm.amount === 'number' &&\n        !isNaN(usm.amount) &&\n        usm.amount === 0 &&\n        typeof usm.threshold === 'number' &&\n        !isNaN(usm.threshold) &&\n        usm.threshold === 0);\n}\nexport { setTransformOptions };\n//# sourceMappingURL=imageTransformOptions.js.map","import { isSEOBot, getFileType, getFileName, getFileExtension, getDevicePixelRatio, getUpscaleString, isImageTransformApplicable, } from '../helpers/imageServiceUtils';\nimport { isMobile } from '../helpers/browserFeatureSupport';\nimport { setTransformParts } from '../helpers/imageTransformParts';\nimport { setTransformOptions } from '../helpers/imageTransformOptions';\nimport { MOBILE_MAX_BG_SITE_LEGACY_WIDTH, DSKTP_MAX_BG_SITE_LEGACY_WIDTH, MOBILE_MAX_BG_SITE_LEGACY_HEIGHT, DSKTP_MAX_BG_SITE_LEGACY_HEIGHT, fittingTypes, } from '../helpers/imageServiceConstants';\n/**\n * returns image transform data\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   [options]           transform options\n *\n * @returns {ImageTransformObject}\n */\nfunction getTransform(fittingType, src, target, options) {\n    const _isSEOBot = isSEOBot(options);\n    const fileType = getFileType(src.id);\n    const fileName = getFileName(src.id, src.name);\n    const devicePixelRatio = _isSEOBot ? 1 : getDevicePixelRatio(target);\n    const fileExtension = getFileExtension(src.id);\n    const preferredExtension = fileExtension;\n    const canTransformImage = isImageTransformApplicable(src.id);\n    const transformsObj = {\n        fileName,\n        fileExtension,\n        fileType,\n        fittingType,\n        preferredExtension,\n        src: {\n            id: src.id,\n            width: src.width,\n            height: src.height,\n            isCropped: false,\n        },\n        focalPoint: {\n            x: src.focalPoint && src.focalPoint.x,\n            y: src.focalPoint && src.focalPoint.y,\n        },\n        parts: [],\n        // options - general\n        devicePixelRatio,\n        quality: 0,\n        upscaleMethod: getUpscaleString(options),\n        progressive: true,\n        watermark: '',\n        unsharpMask: {},\n        filters: {},\n        transformed: canTransformImage,\n    };\n    if (canTransformImage) {\n        setTransformParts(transformsObj, src, target);\n        setTransformOptions(transformsObj, options);\n    }\n    return transformsObj;\n}\n/**\n * returns target data\n * handle legacy BG site if needed\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n *\n * @returns {Object}\n */\nfunction getTarget(fittingType, src, target) {\n    const targetObj = Object.assign({}, target);\n    const _isMobile = isMobile();\n    // handle site BG legacy fitting types (desktop & mobile)\n    switch (fittingType) {\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n        case fittingTypes.LEGACY_BG_NORMAL:\n            const maxBGSiteLegacyWidth = _isMobile\n                ? MOBILE_MAX_BG_SITE_LEGACY_WIDTH\n                : DSKTP_MAX_BG_SITE_LEGACY_WIDTH;\n            const maxBGSiteLegacyHeight = _isMobile\n                ? MOBILE_MAX_BG_SITE_LEGACY_HEIGHT\n                : DSKTP_MAX_BG_SITE_LEGACY_HEIGHT;\n            targetObj.width = Math.min(maxBGSiteLegacyWidth, src.width);\n            targetObj.height = Math.min(maxBGSiteLegacyHeight, Math.round(targetObj.width / (src.width / src.height)));\n            // for legacy types force htmlTag='bg' and devicePixelRatio=1\n            targetObj.pixelAspectRatio = 1;\n    }\n    return targetObj;\n}\nexport { getTransform, getTarget };\n//# sourceMappingURL=transform.js.map","import { template } from '../helpers/utils';\nimport { imageFilters, transformTypes, API_VERSION, fileType, } from '../helpers/imageServiceConstants';\n// transform templates\nconst fitTemplate = template `fit/w_${'width'},h_${'height'}`;\nconst fillTemplate = template `fill/w_${'width'},h_${'height'},al_${'alignment'}`;\nconst fillFocalTemplate = template `fill/w_${'width'},h_${'height'},fp_${'focalPointX'}_${'focalPointY'}`;\nconst cropTemplate = template `crop/x_${'x'},y_${'y'},w_${'width'},h_${'height'}`;\n// legacy templates\nconst legacyCropTemplate = template `crop/w_${'width'},h_${'height'},al_${'alignment'}`;\nconst legacyFillTemplate = template `fill/w_${'width'},h_${'height'},al_${'alignment'}`;\n// upscale template\nconst upscaleTemplate = template `,lg_${'upscaleMethodValue'}`;\n// options templates\nconst qualityTemplate = template `,q_${'quality'}`;\nconst unSharpMaskTemplate = template `,usm_${'radius'}_${'amount'}_${'threshold'}`;\nconst nonProgressiveTemplate = template `,bl`;\nconst watermarkTemplate = template `,wm_${'watermark'}`;\nconst filterTemplatesMap = {\n    [imageFilters.CONTRAST]: template `,con_${'contrast'}`,\n    [imageFilters.BRIGHTNESS]: template `,br_${'brightness'}`,\n    [imageFilters.SATURATION]: template `,sat_${'saturation'}`,\n    [imageFilters.HUE]: template `,hue_${'hue'}`,\n    [imageFilters.BLUR]: template `,blur_${'blur'}`,\n};\nconst autoEncodeTemplate = template `,enc_auto`;\n/**\n * returns image transform uri\n * @param {object}  transformsObj\n *\n * @returns {string}\n */\nfunction getImageURI(transformsObj) {\n    // construct image transforms\n    const transformsObjStrArr = [];\n    // construct transform\n    transformsObj.parts.forEach((transformPart) => {\n        switch (transformPart.transformType) {\n            case transformTypes.CROP:\n                transformsObjStrArr.push(cropTemplate(transformPart));\n                break;\n            case transformTypes.LEGACY_CROP:\n                transformsObjStrArr.push(legacyCropTemplate(transformPart));\n                break;\n            case transformTypes.LEGACY_FILL:\n                let legacyFillStr = legacyFillTemplate(transformPart);\n                if (transformPart.upscale) {\n                    legacyFillStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(legacyFillStr);\n                break;\n            case transformTypes.FIT:\n                let fitStr = fitTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fitStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fitStr);\n                break;\n            case transformTypes.FILL:\n                let fillStr = fillTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fillStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fillStr);\n                break;\n            case transformTypes.FILL_FOCAL:\n                let fillFocalStr = fillFocalTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fillFocalStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fillFocalStr);\n                break;\n        }\n    });\n    let transformsStr = transformsObjStrArr.join('/');\n    // construct transform options\n    // quality\n    if (transformsObj.quality) {\n        transformsStr += qualityTemplate(transformsObj);\n    }\n    // un-sharp mask\n    if (transformsObj.unsharpMask) {\n        transformsStr += unSharpMaskTemplate(transformsObj.unsharpMask);\n    }\n    // progressive\n    if (!transformsObj.progressive) {\n        transformsStr += nonProgressiveTemplate(transformsObj);\n    }\n    // watermark\n    if (transformsObj.watermark) {\n        transformsStr += watermarkTemplate(transformsObj);\n    }\n    // filters\n    if (transformsObj.filters) {\n        transformsStr += Object.keys(transformsObj.filters)\n            .map((filterName) => filterTemplatesMap[filterName](transformsObj.filters))\n            .join('');\n    }\n    // auto encode\n    if (transformsObj.autoEncode && transformsObj.fileType !== fileType.GIF) {\n        transformsStr += autoEncodeTemplate(transformsObj);\n    }\n    // image url string\n    return `${transformsObj.src.id}/${API_VERSION}/${transformsStr}/${transformsObj.fileName}.${transformsObj.preferredExtension}`;\n}\nexport { getImageURI };\n//# sourceMappingURL=transforms.js.map","import { isImageTransformApplicable } from '../helpers/imageServiceUtils';\nimport { getImageURI } from '../engines/transforms';\nimport { getTransform } from './transform';\n/**\n * returns image transform uri\n *\n * @param {string}                  fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   options             transform options\n * @param {Object}                  [transformObj]      transform data object to use\n *\n * @returns {string}\n */\nfunction getURI(fittingType, src, target, options = {}, transformObj) {\n    // check if image transformation is applicable (e.g. .gif, .wix_mp)\n    if (isImageTransformApplicable(src.id)) {\n        transformObj =\n            transformObj || getTransform(fittingType, src, target, options);\n        // set the uri property\n        return getImageURI(transformObj);\n    }\n    return src.id;\n}\nexport { getURI };\n//# sourceMappingURL=uri.js.map","import { alignTypes, fittingTypes } from './imageServiceConstants';\nimport { isPNG } from './imageServiceUtils';\nconst ALIGN_TYPE_TO_POSITION = {\n    [alignTypes.CENTER]: '50% 50%',\n    [alignTypes.TOP_LEFT]: '0% 0%',\n    [alignTypes.TOP_RIGHT]: '100% 0%',\n    [alignTypes.TOP]: '50% 0%',\n    [alignTypes.BOTTOM_LEFT]: '0% 100%',\n    [alignTypes.BOTTOM_RIGHT]: '100% 100%',\n    [alignTypes.BOTTOM]: '50% 100%',\n    [alignTypes.RIGHT]: '100% 50%',\n    [alignTypes.LEFT]: '0% 50%',\n};\nconst POSITION_TO_ALIGN_TYPE = Object.entries(ALIGN_TYPE_TO_POSITION).reduce((acc, [align, position]) => {\n    acc[position] = align;\n    return acc;\n}, {});\nconst TILE_FITTING_TYPES = [\n    fittingTypes.TILE,\n    fittingTypes.TILE_HORIZONTAL,\n    fittingTypes.TILE_VERTICAL,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL,\n];\nconst NON_SCALING_FITTING_TYPES = [\n    fittingTypes.LEGACY_ORIGINAL_SIZE,\n    fittingTypes.ORIGINAL_SIZE,\n    fittingTypes.LEGACY_BG_NORMAL,\n];\nfunction getIsFakeTile(fittingType, src, { width: targetWidth, height: targetHeight, }) {\n    return (fittingType === fittingTypes.TILE &&\n        src.width > targetWidth &&\n        src.height > targetHeight);\n}\n/**\n *\n * @param {FittingType}             fittingType      imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src              source image\n * @param {Dimensions}              target           target container dimensions\n * @param {boolean}                 [isSEOBot=false] whether it is a render for a bot request\n * @returns {Dimensions} scaled dimensions\n */\nfunction getScaledDimensions(fittingType, src, { width, height }, isSEOBot = false) {\n    if (isSEOBot) {\n        return { width, height };\n    }\n    const isScalable = !NON_SCALING_FITTING_TYPES.includes(fittingType);\n    const isFakeTile = getIsFakeTile(fittingType, src, { width, height });\n    const isTile = !isFakeTile && TILE_FITTING_TYPES.includes(fittingType);\n    const _width = isTile ? src.width : width;\n    const _height = isTile ? src.height : height;\n    const scaleFactor = isScalable\n        ? getScaleFactorByWidth(_width, isPNG(src.id))\n        : 1;\n    return {\n        width: isFakeTile ? 1920 : _width * scaleFactor,\n        height: _height * scaleFactor,\n    };\n}\n/**\n *\n * @param {FittingType} fittingType  imageServicesTypes.fittingTypes\n * @param {boolean} isFakeTile\n * @returns {string} fittingType\n */\nfunction getConvertedFitting(fittingType, isFakeTile) {\n    const isTile = TILE_FITTING_TYPES.includes(fittingType) && !isFakeTile;\n    const isFill = fittingType === fittingTypes.SCALE_TO_FILL;\n    return isFill || isTile ? fittingTypes.SCALE_TO_FIT : fittingType;\n}\n/**\n *\n * @param {ImageTransformSource}    src                 source image\n * @param {number || ''}            width\n * @param {number || ''}            height\n * @returns {Dimensions}    width, height\n */\nfunction validateTargetDimensions(src, { width, height }) {\n    if (!width || !height) {\n        const _width = width || Math.min(980, src.width);\n        const heightRatio = _width / src.width;\n        return {\n            width: _width,\n            height: height || src.height * heightRatio,\n        };\n    }\n    return { width, height };\n}\n/**\n *\n * @param {number} width\n * @param {boolean} isHighQuality\n * @return {number}\n */\nfunction getScaleFactorByWidth(width, isHighQuality) {\n    if (width > 900) {\n        return isHighQuality ? 0.05 : 0.15;\n    }\n    else if (width > 500) {\n        return isHighQuality ? 0.1 : 0.18;\n    }\n    else if (width > 200) {\n        return 0.25;\n    }\n    return 1;\n}\n/**\n *\n * @param {number} width\n * @param {FittingType} fittingType imageServicesTypes.fittingTypes\n * @param {boolean} isSEOBot\n * @return {number}\n */\nfunction getBlurValue(width, fittingType, isSEOBot) {\n    if (isSEOBot) {\n        return 0;\n    }\n    if (TILE_FITTING_TYPES.includes(fittingType)) {\n        return 1;\n    }\n    if (width > 200) {\n        return 2;\n    }\n    return 3;\n}\n/**\n *\n * @param {FittingType}                       fittingType\n * @param {ImageTransformSource}              src                  source image\n * @param {{width?: number; height?: number}} target               target element\n * @param {string}                            [alignment='center']\n * @returns {{img}, {container}}\n */\nfunction getCSSOverrides(fittingType, src, target, alignment = 'center') {\n    const returnValue = {\n        img: {},\n        container: {},\n    };\n    if (fittingType === fittingTypes.SCALE_TO_FILL) {\n        const alignTypeFromFocalPoint = src.focalPoint && convertFocalPointToAlignType(src.focalPoint);\n        const alignType = alignTypeFromFocalPoint || alignment;\n        if (src.focalPoint && !alignTypeFromFocalPoint) {\n            returnValue.img = {\n                objectPosition: convertFillFocalToPosition(src, target, src.focalPoint),\n            };\n        }\n        else {\n            returnValue.img = {\n                objectPosition: ALIGN_TYPE_TO_POSITION[alignType],\n            };\n        }\n    }\n    else if ([fittingTypes.LEGACY_ORIGINAL_SIZE, fittingTypes.ORIGINAL_SIZE].includes(fittingType)) {\n        returnValue.img = {\n            objectFit: 'none',\n            top: 'auto',\n            left: 'auto',\n            right: 'auto',\n            bottom: 'auto',\n        };\n    }\n    else if (TILE_FITTING_TYPES.includes(fittingType)) {\n        returnValue.container = {\n            backgroundSize: `${src.width}px ${src.height}px`,\n        };\n    }\n    return returnValue;\n}\n/**\n * Try to convert focal point value to 9 grid alignment value\n *\n * @param {Point}    focalPoint\n * @returns {AlignType} align type\n */\nfunction convertFocalPointToAlignType(focalPoint) {\n    const position = `${focalPoint.x}% ${focalPoint.y}%`;\n    return POSITION_TO_ALIGN_TYPE[position] || '';\n}\n/**\n *\n * @param {Dimensions} src source dimensions\n * @param {width?: number; height?: number} target target dimensions\n * @param {Point} focalPoint x/y as 0-100 percentages\n * @returns {string} in 'x% y%' format\n */\nfunction convertFillFocalToPosition(src, target, focalPoint) {\n    const { width: sW, height: sH } = src;\n    const { width: tW, height: tH } = target;\n    const { x: fpX, y: fpY } = focalPoint;\n    if (!tW || !tH) {\n        return `${fpX}% ${fpY}%`;\n    }\n    const fillScaleFactor = Math.max(tW / sW, tH / sH);\n    const imgScaledW = sW * fillScaleFactor;\n    const imgScaledH = sH * fillScaleFactor;\n    const x = Math.max(0, Math.min(imgScaledW - tW, imgScaledW * (fpX / 100) - tW / 2));\n    const y = Math.max(0, Math.min(imgScaledH - tH, imgScaledH * (fpY / 100) - tH / 2));\n    const posX = x && Math.floor((x / (imgScaledW - tW)) * 100);\n    const posY = y && Math.floor((y / (imgScaledH - tH)) * 100);\n    return `${posX}% ${posY}%`;\n}\nexport { getBlurValue, getConvertedFitting, getCSSOverrides, getIsFakeTile, getScaledDimensions, validateTargetDimensions, };\n//# sourceMappingURL=imagePlaceholderUtils.js.map","import { emptyData } from '../../helpers/imageServiceConstants';\nimport { isImageTransformApplicable, isValidRequest, } from '../../helpers/imageServiceUtils';\nimport { getAttributes } from '../../engines/attributes';\nimport { getTransform, getTarget } from '../transform';\nimport { getURI } from '../uri';\nimport { getSrcset } from '../srcset';\nimport { getScaledDimensions, getBlurValue, getCSSOverrides, validateTargetDimensions, getIsFakeTile, getConvertedFitting, } from '../../helpers/imagePlaceholderUtils';\nconst PLACEHOLDER_IMG_CSS_OVERRIDES = { width: '100%', height: '100%' };\n/**\n * returns image _placeholder_ transform uri and the\n * needed css for alignment and positioning\n *\n * @param {FittingType}             fittingType imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src         image\n * @param {ImagePlaceholderTransformTarget}    target      target dimensions\n * @param {ImageTransformOptions} [options]   environment / transformation  options\n *\n * @returns {ImageDataAttributes}\n */\nfunction getPlaceholder(fittingType, src, target, options = {}) {\n    if (!isValidRequest(fittingType, src, target)) {\n        return emptyData;\n    }\n    const { autoEncode = true, isSEOBot, shouldLoadHQImage } = options;\n    const canTransformImage = isImageTransformApplicable(src.id);\n    if (!canTransformImage || shouldLoadHQImage) {\n        /* Either:\n         * 1. Transform isn't applicable so target is original size applied with fluid CSS\n         * 2. User asked for an HQ image, so they must have supplied target size (width/height)\n         */\n        return getData(fittingType, src, target, Object.assign(Object.assign({}, options), { autoEncode, useSrcset: canTransformImage }));\n    }\n    // If there aren't dimensions, we make them up\n    const newTarget = Object.assign(Object.assign({}, target), validateTargetDimensions(src, target));\n    const { alignment, htmlTag } = newTarget;\n    const isFakeTile = getIsFakeTile(fittingType, src, newTarget);\n    const scaledDimensions = getScaledDimensions(fittingType, src, newTarget, isSEOBot);\n    const blur = getBlurValue(newTarget.width, fittingType, isSEOBot);\n    const convertedFittingType = getConvertedFitting(fittingType, isFakeTile);\n    const overrideCSS = getCSSOverrides(fittingType, src, target, alignment);\n    const { uri } = getData(convertedFittingType, src, Object.assign(Object.assign({}, scaledDimensions), { alignment,\n        htmlTag }), {\n        autoEncode,\n        filters: blur ? { blur } : {},\n    });\n    const { attr = {}, css } = getData(fittingType, src, Object.assign(Object.assign({}, newTarget), { alignment,\n        htmlTag }), {});\n    css.img = css.img || {};\n    css.container = css.container || {};\n    Object.assign(css.img, overrideCSS.img, PLACEHOLDER_IMG_CSS_OVERRIDES);\n    Object.assign(css.container, overrideCSS.container);\n    return { uri, css, attr, transformed: true };\n}\n/**\n * returns image transform uri and the\n * needed css for alignment and positioning\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   [options]          transform options\n *\n * @returns {ImageDataAttributes}\n */\nfunction getData(fittingType, src, target, options) {\n    let data = {};\n    // check if valid request\n    if (isValidRequest(fittingType, src, target)) {\n        // handle site BG legacy fitting types if needed\n        const targetObj = getTarget(fittingType, src, target);\n        // parse request and create working OBJ\n        const transformObj = getTransform(fittingType, src, targetObj, options);\n        data.uri = getURI(fittingType, src, targetObj, options, transformObj);\n        if (options === null || options === void 0 ? void 0 : options.useSrcset) {\n            data.srcset = getSrcset(fittingType, src, targetObj, options, data);\n        }\n        // set the CSS or the SVG property\n        Object.assign(data, getAttributes(transformObj, targetObj), {\n            transformed: transformObj.transformed,\n        });\n    }\n    else {\n        // empty data\n        data = emptyData;\n    }\n    // return data to be used in html\n    return data;\n}\nexport { getData, getPlaceholder };\n//# sourceMappingURL=api.js.map","import { getURI } from './uri';\nfunction getSrcset(fittingType, src, target, options, data) {\n    const dpr = target.pixelAspectRatio || 1;\n    return {\n        dpr: [\n            `${dpr === 1\n                ? data.uri\n                : getURI(fittingType, src, Object.assign(Object.assign({}, target), { pixelAspectRatio: 1 }), options)} 1x`,\n            `${dpr === 2\n                ? data.uri\n                : getURI(fittingType, src, Object.assign(Object.assign({}, target), { pixelAspectRatio: 2 }), options)} 2x`,\n        ],\n    };\n}\nexport { getSrcset };\n//# sourceMappingURL=srcset.js.map","import { htmlTag } from '../helpers/imageServiceConstants';\nimport { get as backgroundAttributes } from './attributes/backgroundAttributes';\nimport { get as imgAttributes } from './attributes/imgAttributes';\nimport { get as SVGAttributes } from './attributes/SVGAttributes';\n/**\n * get CSS or SVG attributes to be used in the browser\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns object\n */\nfunction getAttributes(transformsObj, target) {\n    let attributesGetter;\n    if (target.htmlTag === htmlTag.BG) {\n        attributesGetter = backgroundAttributes;\n    }\n    else if (target.htmlTag === htmlTag.SVG) {\n        attributesGetter = SVGAttributes;\n    }\n    else {\n        attributesGetter = imgAttributes;\n    }\n    return attributesGetter(transformsObj, target);\n}\nexport { getAttributes };\n//# sourceMappingURL=attributes.js.map","import { fittingTypes, alignTypes, htmlTag, upscaleMethods, } from '../../helpers/imageServiceConstants';\nimport { isValidRequest } from '../../helpers/imageServiceUtils';\nimport { populateGlobalFeatureSupport } from '../../helpers/populateFeatureSupport';\nimport { getTarget, getTransform } from '../transform';\nimport { getURI } from '../uri';\n/**\n * returns image transform uri\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   [options]           transform options\n *\n * @returns {{uri: string}}\n */\nfunction getData(fittingType, src, target, options) {\n    // check if valid request\n    if (isValidRequest(fittingType, src, target)) {\n        // handle site BG legacy fitting types\n        const targetObj = getTarget(fittingType, src, target);\n        // parse request and create working OBJ\n        const transformObj = getTransform(fittingType, src, targetObj, options);\n        return {\n            uri: getURI(fittingType, src, targetObj, options || {}, transformObj),\n        };\n    }\n    return { uri: '' };\n}\nexport { populateGlobalFeatureSupport, getData, fittingTypes, alignTypes, htmlTag, upscaleMethods, };\n//# sourceMappingURL=index.js.map","import { getData, populateGlobalFeatureSupport } from '../api/uri/index';\nimport { fittingTypes, htmlTag, alignTypes, } from '../helpers/imageServiceConstants';\nconst wixStatic = 'https://static.wixstatic.com/';\nconst wixStaticWithMedia = 'https://static.wixstatic.com/media/';\nconst HAS_MEDIA_PREFIX_RE = /^media\\//i;\nconst devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\nconst getWixStaticURL = (uri) => HAS_MEDIA_PREFIX_RE.test(uri)\n    ? `${wixStatic}${uri}`\n    : `${wixStaticWithMedia}${uri}`;\nconst getURL = (uri, options) => {\n    const baseHostURL = options && options.baseHostURL;\n    return baseHostURL ? `${baseHostURL}${uri}` : getWixStaticURL(uri);\n};\nfunction getScaleToFitImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FIT, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nfunction getScaleToFillImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FILL, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n        focalPoint: {\n            x: options && options.focalPoint && options.focalPoint.x,\n            y: options && options.focalPoint && options.focalPoint.y,\n        },\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nfunction getCropImageURL(relativeUrl, sourceWidth, sourceHeight, cropX, cropY, cropWidth, cropHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FILL, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n        crop: {\n            x: cropX,\n            y: cropY,\n            width: cropWidth,\n            height: cropHeight,\n        },\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nexport { populateGlobalFeatureSupport, getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, };\n//# sourceMappingURL=api.js.map","import { populateGlobalFeatureSupport, getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, } from './api';\npopulateGlobalFeatureSupport();\nexport { getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, };\n//# sourceMappingURL=index.js.map","import { alignTypes, fittingTypes, htmlTag, upscaleMethods, } from '../../helpers/imageServiceConstants';\nimport { populateGlobalFeatureSupport } from '../../helpers/populateFeatureSupport';\nimport { getData, getPlaceholder } from './api';\nimport { getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStaticWithMedia, } from '../../sdk';\npopulateGlobalFeatureSupport();\nconst sdk = {\n    getScaleToFitImageURL,\n    getScaleToFillImageURL,\n    getCropImageURL,\n};\nexport * from '../../types';\nconst STATIC_MEDIA_URL = wixStaticWithMedia;\nexport { STATIC_MEDIA_URL, alignTypes, fittingTypes, getData, getPlaceholder, htmlTag, populateGlobalFeatureSupport, sdk, upscaleMethods, };\n//# sourceMappingURL=index.js.map","/**\n * image service api version\n */\nconst API_VERSION = 'v1';\n/**\nthe maximum retina factor\n */\nconst MAX_DEVICE_PIXEL_RATIO = 2;\n/**\n site BG legacy max width x height\n */\nconst DSKTP_MAX_BG_SITE_LEGACY_WIDTH = 1920;\nconst DSKTP_MAX_BG_SITE_LEGACY_HEIGHT = 1920;\nconst MOBILE_MAX_BG_SITE_LEGACY_WIDTH = 1000;\nconst MOBILE_MAX_BG_SITE_LEGACY_HEIGHT = 1000;\n/**\n * Enum string values of requested image fitting types\n * Note: TILE_HORIZONTAL, TILE_VERTICAL, FIT_AND_TILE are supported for legacy purposes but are not exposed\n * in the documentation because they should not be exposed for new features\n */\nconst fittingTypes = {\n    SCALE_TO_FILL: 'fill',\n    SCALE_TO_FIT: 'fit',\n    STRETCH: 'stretch',\n    ORIGINAL_SIZE: 'original_size',\n    TILE: 'tile',\n    TILE_HORIZONTAL: 'tile_horizontal',\n    TILE_VERTICAL: 'tile_vertical',\n    FIT_AND_TILE: 'fit_and_tile',\n    LEGACY_STRIP_TILE: 'legacy_strip_tile',\n    LEGACY_STRIP_TILE_HORIZONTAL: 'legacy_strip_tile_horizontal',\n    LEGACY_STRIP_TILE_VERTICAL: 'legacy_strip_tile_vertical',\n    LEGACY_STRIP_SCALE_TO_FILL: 'legacy_strip_fill',\n    LEGACY_STRIP_SCALE_TO_FIT: 'legacy_strip_fit',\n    LEGACY_STRIP_FIT_AND_TILE: 'legacy_strip_fit_and_tile',\n    LEGACY_STRIP_ORIGINAL_SIZE: 'legacy_strip_original_size',\n    LEGACY_ORIGINAL_SIZE: 'actual_size',\n    LEGACY_FIT_WIDTH: 'fitWidth',\n    LEGACY_FIT_HEIGHT: 'fitHeight',\n    LEGACY_FULL: 'full',\n    LEGACY_BG_FIT_AND_TILE: 'legacy_tile',\n    LEGACY_BG_FIT_AND_TILE_HORIZONTAL: 'legacy_tile_horizontal',\n    LEGACY_BG_FIT_AND_TILE_VERTICAL: 'legacy_tile_vertical',\n    LEGACY_BG_NORMAL: 'legacy_normal',\n};\n/**\n * Enum string values of image transform types as passed to the image service api\n */\nconst transformTypes = {\n    FIT: 'fit',\n    FILL: 'fill',\n    FILL_FOCAL: 'fill_focal',\n    CROP: 'crop',\n    LEGACY_CROP: 'legacy_crop',\n    LEGACY_FILL: 'legacy_fill',\n};\n/**\n * Enum string values of requested image align types\n * @type {{CENTER: string, RIGHT: string, LEFT: string, TOP: string, BOTTOM: string, TOP_RIGHT: string, TOP_LEFT: string, BOTTOM_RIGHT: string, BOTTOM_LEFT: string}}\n */\nconst alignTypes = {\n    CENTER: 'center',\n    TOP: 'top',\n    TOP_LEFT: 'top_left',\n    TOP_RIGHT: 'top_right',\n    BOTTOM: 'bottom',\n    BOTTOM_LEFT: 'bottom_left',\n    BOTTOM_RIGHT: 'bottom_right',\n    LEFT: 'left',\n    RIGHT: 'right',\n};\n/**\n * Enum 9Grid alignment to focal point\n */\nconst ALIGN_TYPE_TO_FOCAL_POINT = {\n    [alignTypes.CENTER]: { x: 0.5, y: 0.5 },\n    [alignTypes.TOP_LEFT]: { x: 0, y: 0 },\n    [alignTypes.TOP_RIGHT]: { x: 1.0, y: 0 },\n    [alignTypes.TOP]: { x: 0.5, y: 0 },\n    [alignTypes.BOTTOM_LEFT]: { x: 0, y: 1.0 },\n    [alignTypes.BOTTOM_RIGHT]: { x: 1.0, y: 1.0 },\n    [alignTypes.BOTTOM]: { x: 0.5, y: 1.0 },\n    [alignTypes.RIGHT]: { x: 1.0, y: 0.5 },\n    [alignTypes.LEFT]: { x: 0, y: 0.5 },\n};\n/**\n * Enum string values of image align types as passed to the image service\n */\nconst alignTypesMap = {\n    center: 'c',\n    top: 't',\n    top_left: 'tl',\n    top_right: 'tr',\n    bottom: 'b',\n    bottom_left: 'bl',\n    bottom_right: 'br',\n    left: 'l',\n    right: 'r',\n};\n/**\n * Enum string values of html tag used to construct the css or svg attributes\n *  @type {{BG: string, IMG: string, SVG: string}}\n */\nconst htmlTag = {\n    BG: 'bg',\n    IMG: 'img',\n    SVG: 'svg',\n};\n/**\n * Enum string values of upscale method\n *  @type {{DEFAULT: string, SUPER: string}}\n */\nconst upscaleMethods = {\n    AUTO: 'auto',\n    CLASSIC: 'classic',\n    SUPER: 'super',\n};\n/**\n *  api values of upscale method\n *  @type {{default: number, super: number}}\n */\nconst upscaleMethodsValues = {\n    classic: 1,\n    super: 2,\n};\n/**\n * default unsharp mask values\n *  @type {{radius: number, amount: number, threshold: number}}\n */\nconst defaultUSM = {\n    radius: '0.66',\n    amount: '1.00',\n    threshold: '0.01',\n};\n/**\n * default empty data\n */\nconst emptyData = {\n    uri: '',\n    css: {\n        img: {},\n        container: {},\n    },\n    attr: {\n        img: {},\n        container: {},\n    },\n    transformed: false,\n};\nconst MAX_TRANSFORMED_IMAGE_WIDTH = 5000;\nconst MAX_TRANSFORMED_IMAGE_HEIGHT = 5000;\nconst SAFE_TRANSFORMED_AREA = MAX_TRANSFORMED_IMAGE_WIDTH * MAX_TRANSFORMED_IMAGE_HEIGHT;\n/**\n * super res machine learning upscale factor models -\n * @type {number[]}\n */\nconst SUPER_UPSCALE_MODELS = [1.5, 2, 4];\n/**\n * image qualities\n */\nconst imageScaleDefaults = {\n    HIGH: {\n        size: 1400 * 1400,\n        quality: 90,\n        maxUpscale: 1,\n    },\n    MEDIUM: {\n        size: 600 * 600,\n        quality: 85,\n        maxUpscale: 1,\n    },\n    LOW: {\n        size: 400 * 400,\n        quality: 80,\n        maxUpscale: 1.2,\n    },\n    TINY: {\n        size: 0,\n        quality: 80,\n        maxUpscale: 1.4,\n    },\n};\n/**\n * image quality\n * @type {{HIGH: string, MEDIUM: string, LOW: string, TINY: string}}\n */\nconst imageQuality = {\n    HIGH: 'HIGH',\n    MEDIUM: 'MEDIUM',\n    LOW: 'LOW',\n    TINY: 'TINY',\n};\n/**\n * image filters\n * @type {{CONTRAST: string, BRIGHTNESS: string, SATURATION: string, HUE: string, BLUR: string}}\n */\nconst imageFilters = {\n    CONTRAST: 'contrast',\n    BRIGHTNESS: 'brightness',\n    SATURATION: 'saturation',\n    HUE: 'hue',\n    BLUR: 'blur',\n};\nconst fileType = {\n    JPG: 'jpg',\n    JPEG: 'jpeg',\n    JPE: 'jpe',\n    PNG: 'png',\n    WEBP: 'webp',\n    WIX_ICO_MP: 'wix_ico_mp',\n    WIX_MP: 'wix_mp',\n    GIF: 'gif',\n    SVG: 'svg',\n    UNRECOGNIZED: 'unrecognized',\n};\nconst supportedExtensions = [\n    fileType.JPG,\n    fileType.JPEG,\n    fileType.JPE,\n    fileType.PNG,\n    fileType.GIF,\n    fileType.WEBP,\n];\nexport { alignTypes, alignTypesMap, transformTypes, fittingTypes, htmlTag, upscaleMethods, upscaleMethodsValues, defaultUSM, emptyData, imageQuality, imageFilters, imageScaleDefaults, fileType, supportedExtensions, DSKTP_MAX_BG_SITE_LEGACY_WIDTH, MOBILE_MAX_BG_SITE_LEGACY_WIDTH, DSKTP_MAX_BG_SITE_LEGACY_HEIGHT, MOBILE_MAX_BG_SITE_LEGACY_HEIGHT, SAFE_TRANSFORMED_AREA, SUPER_UPSCALE_MODELS, MAX_DEVICE_PIXEL_RATIO, ALIGN_TYPE_TO_FOCAL_POINT, API_VERSION, };\n//# sourceMappingURL=imageServiceConstants.js.map","const globalFeaturesSupportObj = {\n    /**\n     * @type {object<boolean>}\n     */\n    isMobile: false,\n};\nconst getFeature = function (feature) {\n    return globalFeaturesSupportObj[feature];\n};\nconst setFeature = function (feature, value) {\n    globalFeaturesSupportObj[feature] = value;\n};\nexport { getFeature, setFeature };\n//# sourceMappingURL=imageServiceFeatureSupportObject.js.map","import { setFeature } from './imageServiceFeatureSupportObject';\n/**\n * Populate the global feature support object with browser specific values\n */\nfunction populateGlobalFeatureSupport() {\n    if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n        const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;\n        const isMobileAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        // set is mobile\n        setFeature('isMobile', isSmallScreen && isMobileAgent);\n    }\n}\nexport { populateGlobalFeatureSupport };\n//# sourceMappingURL=populateFeatureSupport.js.map","/**\n * Simple templates.\n * Receives a string with es6 ${...} style template arguments and returns a transformed string.\n * @param string\n * @returns {Function}\n */\nfunction template(strings, ...keys) {\n    return function (...values) {\n        const dict = values[values.length - 1] || {};\n        const result = [strings[0]];\n        keys.forEach(function (key, i) {\n            const value = Number.isInteger(key) ? values[key] : dict[key];\n            result.push(value, strings[i + 1]);\n        });\n        return result.join('');\n    };\n}\n/**\n * Get the last element in an array\n * @param array\n * @returns {*}\n */\nfunction last(array) {\n    return array[array.length - 1];\n}\nexport { last, template };\n//# sourceMappingURL=utils.js.map","import { alignTypes, alignTypesMap, fileType, fittingTypes, imageQuality, imageScaleDefaults, transformTypes, upscaleMethods, upscaleMethodsValues, ALIGN_TYPE_TO_FOCAL_POINT, MAX_DEVICE_PIXEL_RATIO, SUPER_UPSCALE_MODELS, SAFE_TRANSFORMED_AREA, } from './imageServiceConstants';\nimport { last } from './utils';\nconst SUPPORTED_IMAGE_EXTENSIONS = [\n    fileType.PNG,\n    fileType.JPEG,\n    fileType.JPG,\n    fileType.JPE,\n    fileType.WIX_ICO_MP,\n    fileType.WIX_MP,\n];\nconst JPG_EXTENSIONS = [\n    fileType.JPEG,\n    fileType.JPG,\n    fileType.JPE,\n];\n/**\n * checks if image type is supported\n * @param {string}     uri      image source uri\n *\n * @returns {boolean}\n */\nfunction isImageTypeSupported(uri) {\n    return SUPPORTED_IMAGE_EXTENSIONS.includes(getFileExtension(uri));\n}\n/**\n * check request integrity\n * @param {FittingType}             fittingType         imageService.fittingTypes\n * @param {ImageTransformSource}    src\n * @param {ImageTransformTarget}    target\n *\n * @returns {boolean}\n */\nfunction isValidRequest(fittingType, src, target) {\n    return (target &&\n        src &&\n        !isUrlEmptyOrNone(src.id) &&\n        Object.values(fittingTypes).includes(fittingType));\n}\n/**\n * check if image transform is supported for source image\n * @param {string}     uri\n *\n * @returns {boolean}\n */\nfunction isImageTransformApplicable(uri) {\n    return isImageTypeSupported(uri) && !isExternalUrl(uri);\n}\n/**\n * returns true if image is of JPG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isJPG(uri) {\n    return JPG_EXTENSIONS.includes(getFileExtension(uri));\n}\n/**\n * returns true if image is of PNG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isPNG(uri) {\n    return getFileExtension(uri) === fileType.PNG;\n}\n/**\n * returns true if image is of webP type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isWEBP(uri) {\n    return getFileExtension(uri) === fileType.WEBP;\n}\n/**\n * returns true if the url starts with http, https, // or data\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isExternalUrl(url) {\n    return /(^https?)|(^data)|(^\\/\\/)/.test(url);\n}\n/**\n * returns true if the url empty or none string\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isUrlEmptyOrNone(url) {\n    return !url || !url.trim() || url.toLowerCase() === 'none';\n}\n/**\n * returns search bot true or false as indicated in options\n * @param {ImageTransformOptions}   options\n *\n * @returns {boolean}\n */\nfunction isSEOBot(options) {\n    var _a;\n    return (_a = options === null || options === void 0 ? void 0 : options.isSEOBot) !== null && _a !== void 0 ? _a : false;\n}\n// https://jira.wixpress.com/browse/WEED-12667\n// const illegalChars = ['/', '\\\\', '#', '^', '?', '{', '}', '<', '>', '|', '`', '', ':', '\"'].map(encodeURIComponent)\nconst ILLEGAL_CHARS = ['/', '\\\\', '?', '<', '>', '|', '', ':', '\"'].map(encodeURIComponent);\nconst URL_SAFE_ILLEGAL_CHARS = ['\\\\.', '\\\\*'];\nconst ILLEGAL_CHARS_REPLACEMENT = '_';\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n * @param {string}     [name]   optional image source name\n *\n * @returns {string}\n */\nfunction getFileName(uri, name) {\n    const beforeLeadingSlashRegexp = /\\/(.*?)$/;\n    const fileExtensionRegexp = /\\.([^.]*)$/;\n    const illegalCharsRegex = new RegExp(`(${ILLEGAL_CHARS.concat(URL_SAFE_ILLEGAL_CHARS).join('|')})`, 'g');\n    // if name is a non empty string, remove only supported extension if exists and url encode the string\n    if (name && name.length) {\n        let fileName = name;\n        const extension = name.match(fileExtensionRegexp);\n        if (extension &&\n            SUPPORTED_IMAGE_EXTENSIONS.includes(extension[1])) {\n            fileName = name.replace(fileExtensionRegexp, '');\n        }\n        return encodeURIComponent(fileName).replace(illegalCharsRegex, ILLEGAL_CHARS_REPLACEMENT);\n    }\n    // else, trim any preceding media structure from the uri string (like \"media/\" etc.) and remove extension\n    const trimmed = uri.match(beforeLeadingSlashRegexp);\n    const fileName = trimmed ? trimmed[1] : uri;\n    return fileName.replace(fileExtensionRegexp, '');\n}\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n *\n * @returns {FileType}\n */\nfunction getFileType(uri) {\n    if (isJPG(uri)) {\n        return fileType.JPG;\n    }\n    else if (isPNG(uri)) {\n        return fileType.PNG;\n    }\n    else if (isWEBP(uri)) {\n        return fileType.WEBP;\n    }\n    return fileType.UNRECOGNIZED;\n}\n/**\n * returns source image file extension\n * @param {string}     uri      image source uri\n *\n * @returns {string}\n */\nfunction getFileExtension(uri) {\n    const splitURI = /[.]([^.]+)$/.exec(uri);\n    return ((splitURI && /[.]([^.]+)$/.exec(uri)[1]) || '').toLowerCase();\n}\n/**\n * returns scale factor needed if FIT fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFitScaleFactor(sWidth, sHeight, dWidth, dHeight) {\n    return Math.min(dWidth / sWidth, dHeight / sHeight);\n}\n/**\n * returns scale factor needed if FILL fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFillScaleFactor(sWidth, sHeight, dWidth, dHeight) {\n    return Math.max(dWidth / sWidth, dHeight / sHeight);\n}\n/**\n * returns scale factor source target\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n * @param {string}  transformType\n *\n * @returns {number}\n */\nfunction getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType) {\n    let scaleFactor;\n    if (transformType === transformTypes.FILL) {\n        scaleFactor = getFillScaleFactor(sWidth, sHeight, dWidth, dHeight);\n    }\n    else if (transformType === transformTypes.FIT) {\n        scaleFactor = getFitScaleFactor(sWidth, sHeight, dWidth, dHeight);\n    }\n    else {\n        scaleFactor = 1;\n    }\n    return scaleFactor;\n}\n/**\n * get calculated scale factor , width and height while considering wixmp image transform dimension limits\n * @param sWidth\n * @param sHeight\n * @param dWidth\n * @param dHeight\n * @param transformType\n * @returns {{scaleFactor: *, width: *, height: *}}\n */\nfunction getSafeTransformData(sWidth, sHeight, dWidth, dHeight, transformType) {\n    let scaleFactor;\n    // defaults for FILL transform type\n    let width = dWidth;\n    let height = dHeight;\n    // calculate safe image transformed area\n    scaleFactor = getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType);\n    if (transformType === transformTypes.FIT) {\n        width = sWidth * scaleFactor;\n        height = sHeight * scaleFactor;\n    }\n    // adjust target width & height & scaleFactor\n    if (width && height && width * height > SAFE_TRANSFORMED_AREA) {\n        const dimensionScaleFactor = Math.sqrt(SAFE_TRANSFORMED_AREA / (width * height));\n        width *= dimensionScaleFactor;\n        height *= dimensionScaleFactor;\n        // get the new scale factor\n        scaleFactor = getScaleFactor(sWidth, sHeight, width, height, transformType);\n    }\n    return {\n        scaleFactor,\n        width,\n        height,\n    };\n}\n/**\n * returns the destination rectangle\n * @param {number}                  sWidth\n * @param {number}                  sHeight\n * @param {TransformType}           transformType\n * @param {ImageTransformTarget}    target\n * @param {number}                  dpr - device pixel ratio\n * @param {UpscaleMethod}           upscaleMethod\n *\n * @returns {ImageTransformData & {upscaleMethodValue: number}}\n */\nfunction getTransformData(sWidth, sHeight, transformType, target, dpr, upscaleMethod) {\n    // use target dimension is src not provided\n    sWidth = sWidth || target.width;\n    sHeight = sHeight || target.height;\n    // adjust image transform values considering server side transform limitations and performance\n    const { scaleFactor, width, height } = getSafeTransformData(sWidth, sHeight, target.width * dpr, target.height * dpr, transformType);\n    // adjust image transform values to optimizing upsacle quality and payload\n    return getOptimizedTransformData(sWidth, sHeight, width, height, upscaleMethod, scaleFactor, transformType);\n}\n/**\n * converts 9 grid alignment to Focal point position\n * @param {string}  [alignment]\n *\n * @returns {x:number,y:number}\n */\nfunction getFocalPointFrom9GridAlignment(alignment = alignTypes.CENTER) {\n    return ALIGN_TYPE_TO_FOCAL_POINT[alignment];\n}\n/**\n * returns overlapping rectangle where sRect\n * id aligned (according to alignment) within dRect\n * @param {{ width: number; height: number }} sRect rect 1\n * @param {{ width: number, height: number }} dRect rect 2\n * @param {{x: number, y: number}|undefined}  sFP   source image focal point\n * @param {string}                            alignment\n *\n * @returns {{x: number, y: number, width: number, height: number}}\n */\nfunction getAlignedRect(sRect, dRect, sFP, alignment) {\n    const fp = getFocalPoint(sFP) ||\n        getFocalPointFrom9GridAlignment(alignment);\n    const x = Math.max(0, Math.min(sRect.width - dRect.width, fp.x * sRect.width - dRect.width / 2));\n    const y = Math.max(0, Math.min(sRect.height - dRect.height, fp.y * sRect.height - dRect.height / 2));\n    // rect\n    return {\n        x,\n        y,\n        width: Math.min(sRect.width, dRect.width),\n        height: Math.min(sRect.height, dRect.height),\n    };\n}\n/**\n * returns overlapping rectangle between sRect and dRect\n * @param {object}      sRect         rect 1\n * @param {object}      dRect         rect 2\n *\n * @returns {{x:number,y:number,width:number, height:number} || null}\n */\nfunction getOverlappingRect(sRect, dRect) {\n    const width = Math.max(0, Math.min(sRect.width, dRect.x + dRect.width) - Math.max(0, dRect.x));\n    const height = Math.max(0, Math.min(sRect.height, dRect.y + dRect.height) - Math.max(0, dRect.y));\n    const isValidRect = width && height && (sRect.width !== width || sRect.height !== height);\n    // return overlapping sRect/dRect rectangle(x, y, width, height)\n    return isValidRect\n        ? {\n            x: Math.max(0, dRect.x),\n            y: Math.max(0, dRect.y),\n            width,\n            height,\n        }\n        : null;\n}\n/**\n * returns pixel aspect ratio value\n * @param {ImageTransformTarget}    target\n *\n * @returns {number}\n */\nfunction getDevicePixelRatio(target) {\n    return Math.min(target.pixelAspectRatio || 1, MAX_DEVICE_PIXEL_RATIO);\n}\n/**\n * returns target alignment value\n * @param {ImageTransformTarget}    target\n *\n * @returns {string}\n */\nfunction getAlignment(target) {\n    return ((target.alignment && alignTypesMap[target.alignment]) ||\n        alignTypesMap[alignTypes.CENTER]);\n}\n/**\n * returns the focal point value, if no focal point passed use alignment\n * @param {{x: number, y: number}|undefined} focalPoint\n */\nfunction getFocalPoint(focalPoint) {\n    let fp;\n    if (focalPoint &&\n        typeof focalPoint.x === 'number' &&\n        !isNaN(focalPoint.x) &&\n        typeof focalPoint.y === 'number' &&\n        !isNaN(focalPoint.y)) {\n        fp = {\n            x: roundToFixed(Math.max(0, Math.min(100, focalPoint.x)) / 100, 2),\n            y: roundToFixed(Math.max(0, Math.min(100, focalPoint.y)) / 100, 2),\n        };\n    }\n    return fp;\n}\n/**\n * returns preferred image quality value\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {number}\n */\nfunction getPreferredImageQuality(imageWidth, imageHeight) {\n    return imageScaleDefaults[getImageQualityKey(imageWidth, imageHeight)]\n        .quality;\n}\n/**\n * returns the scale descriptor of CLASSIC upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getClassicScaleData(sWidth, sHeight) {\n    const imageKey = getImageQualityKey(sWidth, sHeight);\n    return {\n        optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n        upscaleMethodValue: upscaleMethodsValues.classic,\n        forceUSM: false,\n    };\n}\n/**\n * returns the scale descriptor of AUTO upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getAutoScaleData(sWidth, sHeight) {\n    const imageKey = getImageQualityKey(sWidth, sHeight);\n    return {\n        optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n        upscaleMethodValue: upscaleMethodsValues.classic,\n        forceUSM: false,\n    };\n}\n/**\n * returns the scale descriptor of SUPER upscale method\n * @param scaleFactor\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getSuperScaleData(scaleFactor) {\n    return {\n        optimizedScaleFactor: last(SUPER_UPSCALE_MODELS),\n        upscaleMethodValue: upscaleMethodsValues.super,\n        forceUSM: !(SUPER_UPSCALE_MODELS.includes(scaleFactor) ||\n            scaleFactor > last(SUPER_UPSCALE_MODELS)),\n    };\n}\n/**\n * returns upscale descriptor object\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {string}    upscaleMethod\n * @param {number}    scaleFactor\n *\n * @returns  {{maxScale: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod) {\n    if (upscaleMethod === 'auto') {\n        return getAutoScaleData(sWidth, sHeight);\n    }\n    else if (upscaleMethod === 'super') {\n        return getSuperScaleData(scaleFactor);\n    }\n    // assuming 'classic' method\n    return getClassicScaleData(sWidth, sHeight);\n}\n/**\n * returns optimized upscale data, considering requested upscale method , optimize upscale for best quality and bandwidth\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {number}    tWidth\n * @param {number}    tHeight\n * @param {UpscaleMethod}    upscaleMethod\n * @param {number}    scaleFactor\n * @param {TransformType}    transformType\n *\n * @returns  {ImageTransformData}\n */\nfunction getOptimizedTransformData(sWidth, sHeight, tWidth, tHeight, upscaleMethod, scaleFactor, transformType) {\n    const { optimizedScaleFactor, upscaleMethodValue, forceUSM, } = getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod);\n    let width = tWidth;\n    let height = tHeight;\n    if (scaleFactor <= optimizedScaleFactor) {\n        // target upscale within limits or downscale\n        return {\n            width,\n            height,\n            scaleFactor,\n            upscaleMethodValue,\n            forceUSM,\n            cssUpscaleNeeded: false,\n        };\n    }\n    // limited upscale\n    switch (transformType) {\n        case transformTypes.FILL:\n            width = tWidth * (optimizedScaleFactor / scaleFactor);\n            height = tHeight * (optimizedScaleFactor / scaleFactor);\n            break;\n        case transformTypes.FIT:\n            width = sWidth * optimizedScaleFactor;\n            height = sHeight * optimizedScaleFactor;\n            break;\n        default:\n            break;\n    }\n    // adjust transform values\n    return {\n        width,\n        height,\n        scaleFactor: optimizedScaleFactor,\n        upscaleMethodValue,\n        forceUSM,\n        cssUpscaleNeeded: true,\n    };\n}\n/**\n * returns image quality key\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {ImageQuality}\n */\nfunction getImageQualityKey(imageWidth, imageHeight) {\n    const size = imageWidth * imageHeight;\n    if (size > imageScaleDefaults[imageQuality.HIGH].size) {\n        return imageQuality.HIGH;\n    }\n    else if (size > imageScaleDefaults[imageQuality.MEDIUM].size) {\n        return imageQuality.MEDIUM;\n    }\n    else if (size > imageScaleDefaults[imageQuality.LOW].size) {\n        return imageQuality.LOW;\n    }\n    return imageQuality.TINY;\n}\n/**\n * return the actual rounded dimension of a scaled rectangle\n * @param sWidth\n * @param sHeight\n * @param tWidth\n * @param tHeight\n * @param transformType\n * @returns {{width: number, height: number}}\n */\nfunction getDimension(sWidth, sHeight, tWidth, tHeight, transformType) {\n    const scaleFactor = getScaleFactor(sWidth, sHeight, tWidth, tHeight, transformType);\n    return {\n        width: Math.round(sWidth * scaleFactor),\n        height: Math.round(sHeight * scaleFactor),\n    };\n}\n/**\n * rounds number n digit precision and converts to string\n * @param {number}      value\n * @param {number}      precision\n *\n * @returns {string}\n */\nfunction roundToFixed(value, precision) {\n    const truncatePrecision = Math.pow(10, precision || 0);\n    return ((value * truncatePrecision) / truncatePrecision).toFixed(precision);\n}\n/**\n * get normalize scale method\n * @param {ImageTransformOptions} [options]\n * @returns {UpscaleMethod}\n */\nfunction getUpscaleString(options) {\n    if (!options || !options.upscaleMethod) {\n        return upscaleMethods.AUTO;\n    }\n    return (upscaleMethods[options.upscaleMethod.toUpperCase()] || upscaleMethods.AUTO);\n}\nexport { getAlignedRect, getAlignment, getDevicePixelRatio, getDimension, getFileExtension, getFileName, getFileType, getFocalPoint, getOverlappingRect, getPreferredImageQuality, getScaleFactor, getTransformData, getUpscaleString, isExternalUrl, isImageTransformApplicable, isImageTypeSupported, isSEOBot, isValidRequest, isPNG, isWEBP, roundToFixed, };\n//# sourceMappingURL=imageServiceUtils.js.map","import { alignTypes, fittingTypes } from '../../helpers/imageServiceConstants';\n/**\n * returns BG tag CSS data\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns {BackgroundImageAttributes}\n */\nfunction getCSS(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n        },\n    };\n    const { css } = attributes;\n    const { fittingType } = transformsObj;\n    // set fitting\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:\n            css.container.backgroundSize = 'contain';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.STRETCH:\n            css.container.backgroundSize = '100% 100%';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:\n            css.container.backgroundSize = 'cover';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n        case fittingTypes.TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-x';\n            break;\n        case fittingTypes.TILE_VERTICAL:\n        case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-y';\n            break;\n        case fittingTypes.TILE:\n        case fittingTypes.LEGACY_STRIP_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:\n            css.container.backgroundSize = 'contain';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.FIT_AND_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        // Legacy old editor bg types.\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat';\n            break;\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-x';\n            break;\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'repeat-y';\n            break;\n        case fittingTypes.LEGACY_BG_NORMAL:\n            css.container.backgroundSize = 'auto';\n            css.container.backgroundRepeat = 'no-repeat';\n            break;\n    }\n    // set alignment\n    switch (target.alignment) {\n        case alignTypes.CENTER:\n            css.container.backgroundPosition = 'center center'; // 50% 50%\n            break;\n        case alignTypes.LEFT:\n            css.container.backgroundPosition = 'left center'; // 0% 50%\n            break;\n        case alignTypes.RIGHT:\n            css.container.backgroundPosition = 'right center'; // 100% 50%\n            break;\n        case alignTypes.TOP:\n            css.container.backgroundPosition = 'center top'; // 50% 0%\n            break;\n        case alignTypes.BOTTOM:\n            css.container.backgroundPosition = 'center bottom'; // 50% 100%\n            break;\n        case alignTypes.TOP_RIGHT:\n            css.container.backgroundPosition = 'right top'; // 100% 0%\n            break;\n        case alignTypes.TOP_LEFT:\n            css.container.backgroundPosition = 'left top'; // 0% 0%\n            break;\n        case alignTypes.BOTTOM_RIGHT:\n            css.container.backgroundPosition = 'right bottom'; // 100% 100%\n            break;\n        case alignTypes.BOTTOM_LEFT:\n            css.container.backgroundPosition = 'left bottom'; // 0% 100%\n            break;\n    }\n    // return background CSS\n    return attributes;\n}\nexport { getCSS as get };\n//# sourceMappingURL=backgroundAttributes.js.map","import { alignTypes, fittingTypes } from '../../helpers/imageServiceConstants';\n/**\n * align type to position\n * @param verticalMiddle\n * @param horizontalMiddle\n * @param target\n * @returns {{}}\n */\nfunction alignTypeToPosition(verticalMiddle, horizontalMiddle, target) {\n    return {\n        [alignTypes.TOP_LEFT]: { top: 0, left: 0 },\n        [alignTypes.TOP_RIGHT]: { top: 0, right: 0 },\n        [alignTypes.TOP]: { top: 0, left: horizontalMiddle },\n        [alignTypes.BOTTOM_LEFT]: { bottom: 0, left: 0 },\n        [alignTypes.BOTTOM_RIGHT]: { bottom: 0, right: 0 },\n        [alignTypes.BOTTOM]: { bottom: 0, left: horizontalMiddle },\n        [alignTypes.RIGHT]: { top: verticalMiddle, right: 0 },\n        [alignTypes.LEFT]: { top: verticalMiddle, left: 0 },\n        [alignTypes.CENTER]: {\n            width: target.width,\n            height: target.height,\n            objectFit: 'none',\n        },\n    };\n}\nconst alignTypeToPositionStr = {\n    [alignTypes.CENTER]: 'center',\n    [alignTypes.TOP]: 'top',\n    [alignTypes.TOP_LEFT]: 'top left',\n    [alignTypes.TOP_RIGHT]: 'top right',\n    [alignTypes.BOTTOM]: 'bottom',\n    [alignTypes.BOTTOM_LEFT]: 'bottom left',\n    [alignTypes.BOTTOM_RIGHT]: 'bottom right',\n    [alignTypes.LEFT]: 'left',\n    [alignTypes.RIGHT]: 'right',\n};\nconst aligmentDefaults = {\n    position: 'absolute',\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto',\n};\n/**\n * returns image tag CSS data\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns {ImageAttributes}\n */\nfunction getCSS(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n            img: {},\n        },\n    };\n    const { css } = attributes;\n    const { fittingType } = transformsObj;\n    const alignType = target.alignment;\n    css.container.position = 'relative';\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n            if (transformsObj.parts && transformsObj.parts.length) {\n                css.img.width = transformsObj.parts[0].width;\n                css.img.height = transformsObj.parts[0].height;\n            }\n            else {\n                css.img.width = transformsObj.src.width;\n                css.img.height = transformsObj.src.height;\n            }\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'contain';\n            css.img.objectPosition =\n                alignTypeToPositionStr[alignType] || 'unset';\n            break;\n        // BG_NORMAL is a sitebackground legacy for original size fitting type.\n        // target width and height were modified in transform.js\n        case fittingTypes.LEGACY_BG_NORMAL:\n            css.img.width = '100%';\n            css.img.height = '100%';\n            css.img.objectFit = 'none';\n            css.img.objectPosition =\n                alignTypeToPositionStr[alignType] || 'unset';\n            break;\n        case fittingTypes.STRETCH:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'fill';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            css.img.width = target.width;\n            css.img.height = target.height;\n            css.img.objectFit = 'cover';\n            break;\n    }\n    // set alignment in a private case where the image src is smaller than the image container,\n    if (typeof css.img.width === 'number' &&\n        typeof css.img.height === 'number' &&\n        (css.img.width !== target.width || css.img.height !== target.height)) {\n        const verticalMiddle = Math.round((target.height - css.img.height) / 2);\n        const horizontalMiddle = Math.round((target.width - css.img.width) / 2);\n        Object.assign(css.img, aligmentDefaults, alignTypeToPosition(verticalMiddle, horizontalMiddle, target)[alignType]);\n    }\n    return attributes;\n}\nexport { getCSS as get };\n//# sourceMappingURL=imgAttributes.js.map","import { fittingTypes, alignTypes, transformTypes, } from '../../helpers/imageServiceConstants';\nimport { getDimension, isImageTransformApplicable, } from '../../helpers/imageServiceUtils';\n/* eslint-disable indent */\n/**\n * get CSS or SVG attributes to be used in the browser\n * @param {ImageTransformObject}  transformsObj  transform parts object\n * @param {ImageTransformTarget}  target\n *\n * @returns {SVGImageAttributes}\n */\nfunction getSvgAttr(transformsObj, target) {\n    const attributes = {\n        css: {\n            container: {},\n        },\n        attr: {\n            container: {},\n            img: {},\n        },\n    };\n    const { css, attr } = attributes;\n    const { fittingType } = transformsObj;\n    const alignType = target.alignment;\n    const { width: sourceWidth, height: sourceHeight } = transformsObj.src;\n    let imageScale;\n    css.container.position = 'relative';\n    // populate SVG attributes object\n    // eslint-disable-line indent\n    switch (fittingType) {\n        case fittingTypes.ORIGINAL_SIZE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.TILE:\n            if (transformsObj.parts && transformsObj.parts.length) {\n                attr.img.width = transformsObj.parts[0].width;\n                attr.img.height = transformsObj.parts[0].height;\n            }\n            else {\n                attr.img.width = sourceWidth;\n                attr.img.height = sourceHeight;\n            }\n            attr.img.preserveAspectRatio = 'xMidYMid slice';\n            break;\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n            attr.img.width = '100%';\n            attr.img.height = '100%';\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = '';\n            break;\n        case fittingTypes.STRETCH:\n            attr.img.width = target.width;\n            attr.img.height = target.height;\n            attr.img.x = 0;\n            attr.img.y = 0;\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = 'none';\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            if (!isImageTransformApplicable(transformsObj.src.id)) {\n                imageScale = getDimension(sourceWidth, sourceHeight, target.width, target.height, transformTypes.FILL);\n                attr.img.width = imageScale.width;\n                attr.img.height = imageScale.height;\n            }\n            else {\n                attr.img.width = target.width;\n                attr.img.height = target.height;\n            }\n            attr.img.x = 0;\n            attr.img.y = 0;\n            attr.img.transform = '';\n            attr.img.preserveAspectRatio = 'xMidYMid slice';\n            break;\n    }\n    // set alignment for cases where the requested src is smaller or bigger than the target element,\n    if (typeof attr.img.width === 'number' &&\n        typeof attr.img.height === 'number' &&\n        (attr.img.width !== target.width || attr.img.height !== target.height)) {\n        // x and y to use in svg <pattern> element\n        let x = 0;\n        let y = 0;\n        let right;\n        let bottom;\n        if (fittingType === fittingTypes.TILE) {\n            right = target.width % attr.img.width;\n            bottom = target.height % attr.img.height;\n        }\n        else {\n            right = target.width - attr.img.width;\n            bottom = target.height - attr.img.height;\n        }\n        const center = Math.round(right / 2);\n        const middle = Math.round(bottom / 2);\n        switch (alignType) {\n            case alignTypes.TOP_LEFT:\n                x = 0;\n                y = 0;\n                break;\n            case alignTypes.TOP:\n                x = center;\n                y = 0;\n                break;\n            case alignTypes.TOP_RIGHT:\n                x = right;\n                y = 0;\n                break;\n            case alignTypes.LEFT:\n                x = 0;\n                y = middle;\n                break;\n            case alignTypes.CENTER:\n                x = center;\n                y = middle;\n                break;\n            case alignTypes.RIGHT:\n                x = right;\n                y = middle;\n                break;\n            case alignTypes.BOTTOM_LEFT:\n                x = 0;\n                y = bottom;\n                break;\n            case alignTypes.BOTTOM:\n                x = center;\n                y = bottom;\n                break;\n            case alignTypes.BOTTOM_RIGHT:\n                x = right;\n                y = bottom;\n                break;\n        }\n        attr.img.x = x;\n        attr.img.y = y;\n    }\n    attr.container.width = target.width;\n    attr.container.height = target.height;\n    attr.container.viewBox = [0, 0, target.width, target.height].join(' ');\n    // return attributes object\n    return attributes;\n}\n/* eslint-enable indent */\nexport { getSvgAttr as get };\n//# sourceMappingURL=SVGAttributes.js.map","import { getFeature } from './imageServiceFeatureSupportObject';\n/**\n * get a browser detection if running on mobile device\n *\n * @returns {boolean}\n */\nfunction isMobile() {\n    return getFeature('isMobile');\n}\nexport { isMobile };\n//# sourceMappingURL=browserFeatureSupport.js.map","import { fittingTypes, transformTypes, alignTypesMap, } from './imageServiceConstants';\nimport { getAlignment, getScaleFactor, getOverlappingRect, getAlignedRect, getTransformData, getFocalPoint, } from './imageServiceUtils';\n/**\n * request analysis, returns parsed transforms object\n * @param {object}                  transformsObj\n * @param {ImageTransformSource}    src\n * @param {ImageTransformTarget}    target\n */\nfunction setTransformParts(transformsObj, src, target) {\n    let rect;\n    // crop source image if needed\n    // set crop part and adjust source dimensions\n    if (src.crop) {\n        rect = getOverlappingRect(src, src.crop);\n        if (rect) {\n            transformsObj.src.width = rect.width;\n            transformsObj.src.height = rect.height;\n            transformsObj.src.isCropped = true;\n            transformsObj.parts.push(getCropPart(rect));\n        }\n    }\n    // set additional transform part\n    switch (transformsObj.fittingType) {\n        case fittingTypes.SCALE_TO_FIT:\n        case fittingTypes.LEGACY_FIT_WIDTH:\n        case fittingTypes.LEGACY_FIT_HEIGHT:\n        case fittingTypes.LEGACY_FULL:\n        case fittingTypes.FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n        case fittingTypes.LEGACY_BG_NORMAL:\n            // fit\n            transformsObj.parts.push(getFitPart(transformsObj, target));\n            break;\n        case fittingTypes.SCALE_TO_FILL:\n            // fill\n            transformsObj.parts.push(getFillPart(transformsObj, target));\n            break;\n        case fittingTypes.STRETCH:\n            // stretch\n            transformsObj.parts.push(getStretchPart(transformsObj, target));\n            break;\n        case fittingTypes.TILE_HORIZONTAL:\n        case fittingTypes.TILE_VERTICAL:\n        case fittingTypes.TILE:\n        case fittingTypes.LEGACY_ORIGINAL_SIZE:\n        case fittingTypes.ORIGINAL_SIZE:\n            // use crop transform\n            // if crop of source image was requested adjust cropping rectangle\n            rect = getAlignedRect(transformsObj.src, target, transformsObj.focalPoint, target.alignment);\n            if (transformsObj.src.isCropped) {\n                Object.assign(transformsObj.parts[0], rect);\n                // update source width & height accordingly\n                transformsObj.src.width = rect.width;\n                transformsObj.src.height = rect.height;\n            }\n            else {\n                transformsObj.parts.push(getCropPart(rect));\n            }\n            break;\n        // ---------------------------------------------------------------------------------------\n        // handles a legacy bug on bgImageStrip, background html tag\n        // component Full Width Strip stored incorrect image source width and height\n        // ---------------------------------------------------------------------------------------\n        case fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_STRIP_TILE_VERTICAL:\n        case fittingTypes.LEGACY_STRIP_TILE:\n        case fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:\n            // crop request of source image is not supported\n            // use legacy crop\n            transformsObj.parts.push(getLegacyCropPart(target));\n            break;\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:\n        case fittingTypes.LEGACY_STRIP_FIT_AND_TILE:\n            // legacy fit\n            transformsObj.parts.push(getLegacyFitPart(target));\n            break;\n        case fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:\n            // legacy fill\n            transformsObj.parts.push(getLegacyFillPart(target));\n            break;\n    }\n}\n/**\n * returns fit part of the image transform uri\n * @param {object}                  transformsObj\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformFitPart}\n */\nfunction getFitPart(transformsObj, target) {\n    // calculate the transformed image size needed\n    const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FIT, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);\n    const transformType = transformTypes.FILL;\n    // return fit transform data\n    return {\n        transformType,\n        width: Math.round(transformedData.width),\n        height: Math.round(transformedData.height),\n        alignment: alignTypesMap.center,\n        upscale: transformedData.scaleFactor > 1,\n        forceUSM: transformedData.forceUSM,\n        scaleFactor: transformedData.scaleFactor,\n        cssUpscaleNeeded: transformedData.cssUpscaleNeeded,\n        upscaleMethodValue: transformedData.upscaleMethodValue,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformObject} transformsObj\n * @param {ImageTransformTarget} target\n *\n * @returns {TransformFillPart}\n */\nfunction getFillPart(transformsObj, target) {\n    // calculate the transformed image size needed\n    const transformedData = getTransformData(transformsObj.src.width, transformsObj.src.height, transformTypes.FILL, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);\n    const focalPoint = getFocalPoint(transformsObj.focalPoint);\n    const transformType = focalPoint\n        ? transformTypes.FILL_FOCAL\n        : transformTypes.FILL;\n    return {\n        transformType,\n        width: Math.round(transformedData.width),\n        height: Math.round(transformedData.height),\n        alignment: getAlignment(target),\n        focalPointX: focalPoint && focalPoint.x,\n        focalPointY: focalPoint && focalPoint.y,\n        upscale: transformedData.scaleFactor > 1,\n        forceUSM: transformedData.forceUSM,\n        scaleFactor: transformedData.scaleFactor,\n        cssUpscaleNeeded: transformedData.cssUpscaleNeeded,\n        upscaleMethodValue: transformedData.upscaleMethodValue,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformObject} transformsObj\n * @param {ImageTransformTarget} target\n *\n * @returns {TransformFitPart}\n */\nfunction getStretchPart(transformsObj, target) {\n    // stretch data\n    const scaleFactor = getScaleFactor(transformsObj.src.width, transformsObj.src.height, target.width, target.height, transformTypes.FILL);\n    const clonedTarget = Object.assign({}, target);\n    clonedTarget.width = transformsObj.src.width * scaleFactor;\n    clonedTarget.height = transformsObj.src.height * scaleFactor;\n    // return stretch part\n    return getFitPart(transformsObj, clonedTarget);\n}\n/**\n * returns crop part of the image transform uri\n * @param {{x: number, y: number, width: number, height: number}}  rect     x, y, width, height\n *\n * @returns {TransformCropPart}\n */\nfunction getCropPart(rect) {\n    return {\n        transformType: transformTypes.CROP,\n        x: Math.round(rect.x),\n        y: Math.round(rect.y),\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n        upscale: false,\n        forceUSM: false,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n// ---------------------------------------------------------------------------------------\n// handles a legacy bug on bgImageStrip, background html tag\n// component Full Width Strip stored incorrect image source width and height\n// ---------------------------------------------------------------------------------------\n/**\n * returns fit part of the image transform uri\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformLegacyFitPart}\n */\nfunction getLegacyFitPart(target) {\n    return {\n        transformType: transformTypes.FIT,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        upscale: false,\n        forceUSM: true,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n/**\n * returns fill part of the image transform uri\n * @param {ImageTransformTarget}    target\n *\n * @returns {TransformLegacyFillPart}\n */\nfunction getLegacyFillPart(target) {\n    return {\n        transformType: transformTypes.LEGACY_FILL,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        alignment: getAlignment(target),\n        upscale: false,\n        forceUSM: true,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\n/**\n * returns legacy crop part of the image transform uri\n * @param {ImageTransformTarget}     target\n *\n * @returns {TransformLegacyCropPart}\n */\nfunction getLegacyCropPart(target) {\n    return {\n        transformType: transformTypes.LEGACY_CROP,\n        width: Math.round(target.width),\n        height: Math.round(target.height),\n        alignment: getAlignment(target),\n        upscale: false,\n        forceUSM: false,\n        scaleFactor: 1,\n        cssUpscaleNeeded: false,\n    };\n}\nexport { setTransformParts };\n//# sourceMappingURL=imageTransformParts.js.map","import { last } from './utils';\nimport { getPreferredImageQuality, roundToFixed } from './imageServiceUtils';\nimport { defaultUSM, fileType, imageFilters } from './imageServiceConstants';\n/**\n * returns image filters part of the image transform uri\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   [options]\n */\nfunction setTransformOptions(transformsObj, options) {\n    var _a;\n    options = options || {};\n    // options - general\n    transformsObj.quality = getQuality(transformsObj, options);\n    transformsObj.progressive = getProgressive(options);\n    transformsObj.watermark = getWatermark(options);\n    transformsObj.autoEncode = (_a = options.autoEncode) !== null && _a !== void 0 ? _a : true;\n    // options - filters & adjustments\n    transformsObj.unsharpMask = getUnsharpMask(transformsObj, options);\n    transformsObj.filters = getFilters(options);\n}\n/**\n *\n * @param {ImageTransformOptions}   options\n * @returns {string}\n */\nfunction getWatermark(options) {\n    return options.watermark;\n}\n/**\n * returns progressive if required\n * @param {ImageTransformOptions}   options\n *\n * @returns {boolean}\n */\nfunction getProgressive(options) {\n    return options.progressive !== false;\n}\n/**\n * returns image filters part of the image transform uri\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   options\n *\n * @returns {number}\n */\nfunction getQuality(transformsObj, options) {\n    const isPNG = transformsObj.fileType === fileType.PNG;\n    const isJPG = transformsObj.fileType === fileType.JPG;\n    const isQualitySupported = isJPG || isPNG;\n    if (isQualitySupported) {\n        const transformData = last(transformsObj.parts);\n        const defaultQuality = getPreferredImageQuality(transformData.width, transformData.height);\n        let quality = options.quality && options.quality >= 5 && options.quality <= 90\n            ? options.quality\n            : defaultQuality;\n        // increase quality by 5 for webp images\n        quality = isPNG ? quality + 5 : quality;\n        return quality;\n    }\n    // quality not supported\n    return 0;\n}\n/**\n * returns the desired transformed image filters\n * @param {ImageTransformOptions}   options\n *\n * @returns {object}\n */\nfunction getFilters(options) {\n    const filterOptions = options.filters || {};\n    const filters = {};\n    // contrast\n    if (isValidImageFilter(filterOptions[imageFilters.CONTRAST], -100, 100)) {\n        filters[imageFilters.CONTRAST] = filterOptions[imageFilters.CONTRAST];\n    }\n    // brightness\n    if (isValidImageFilter(filterOptions[imageFilters.BRIGHTNESS], -100, 100)) {\n        filters[imageFilters.BRIGHTNESS] = filterOptions[imageFilters.BRIGHTNESS];\n    }\n    // saturation\n    if (isValidImageFilter(filterOptions[imageFilters.SATURATION], -100, 100)) {\n        filters[imageFilters.SATURATION] = filterOptions[imageFilters.SATURATION];\n    }\n    // hue\n    if (isValidImageFilter(filterOptions[imageFilters.HUE], -180, 180)) {\n        filters[imageFilters.HUE] = filterOptions[imageFilters.HUE];\n    }\n    // blur\n    if (isValidImageFilter(filterOptions[imageFilters.BLUR], 0, 100)) {\n        filters[imageFilters.BLUR] = filterOptions[imageFilters.BLUR];\n    }\n    return filters;\n}\n/**\n * indicates if requested filter value is valid\n * @param {number|undefined}  filterValue     filter's value\n * @param {number}  minValue        min range\n * @param {number}  maxValue        max range\n *\n * @returns {boolean}\n */\nfunction isValidImageFilter(filterValue, minValue, maxValue) {\n    // check if filter name and filter values range valid\n    return (typeof filterValue === 'number' &&\n        !isNaN(filterValue) &&\n        filterValue !== 0 &&\n        filterValue >= minValue &&\n        filterValue <= maxValue);\n}\n/**\n * returns the desired transformed image unSharpMask values\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformOptions}   options\n *\n * @returns {object}\n */\nfunction getUnsharpMask(transformsObj, options) {\n    var _a, _b, _c;\n    // If options.unsharpMask is a valid value, use it\n    if (isUSMValid(options.unsharpMask)) {\n        // If we got usm, change values to have trailing zeros (.00), else return undefined\n        return {\n            radius: roundToFixed((_a = options.unsharpMask) === null || _a === void 0 ? void 0 : _a.radius, 2),\n            amount: roundToFixed((_b = options.unsharpMask) === null || _b === void 0 ? void 0 : _b.amount, 2),\n            threshold: roundToFixed((_c = options.unsharpMask) === null || _c === void 0 ? void 0 : _c.threshold, 2),\n        };\n        // if options.unsharpMask is not all zeros and not valid and usm should be used, use default\n    }\n    else if (!isZeroUSM(options.unsharpMask) && isUSMNeeded(transformsObj)) {\n        return defaultUSM;\n    }\n    return;\n}\n/**\n * indicates if usm is needed\n * @param {ImageTransformObject}      transformsObj   transform parts object\n *\n * @returns {boolean}\n */\nfunction isUSMNeeded(transformsObj) {\n    // ---------------------------------------------------------------------------------------\n    // do not apply usm if transformed image width & height is same as source image or larger\n    // and no force usm is desired\n    // ---------------------------------------------------------------------------------------\n    const transformPart = last(transformsObj.parts);\n    const upscale = transformPart.scaleFactor >= 1;\n    // return if usm is needed\n    return !upscale || transformPart.forceUSM;\n}\n/**\n * indicates if all usm values are presented and in range\n * @param {OptionUnsharpMask|undefined}  usm     unsharp mask\n *\n * @returns {boolean}\n */\nfunction isUSMValid(usm) {\n    usm = usm || {};\n    const radius = typeof usm.radius === 'number' &&\n        !isNaN(usm.radius) &&\n        usm.radius >= 0.1 &&\n        usm.radius <= 500;\n    const amount = typeof usm.amount === 'number' &&\n        !isNaN(usm.amount) &&\n        usm.amount >= 0 &&\n        usm.amount <= 10;\n    const threshold = typeof usm.threshold === 'number' &&\n        !isNaN(usm.threshold) &&\n        usm.threshold >= 0 &&\n        usm.threshold <= 255;\n    // return is a valid USM data\n    return radius && amount && threshold;\n}\n/**\n * indicates if all usm values are presented and are zero. an explicit request to not apply usm\n * @param {OptionUnsharpMask|undefined}  usm     unsharp mask\n *\n * @returns {boolean}\n */\nfunction isZeroUSM(usm) {\n    usm = usm || {};\n    return (typeof usm.radius === 'number' &&\n        !isNaN(usm.radius) &&\n        usm.radius === 0 &&\n        typeof usm.amount === 'number' &&\n        !isNaN(usm.amount) &&\n        usm.amount === 0 &&\n        typeof usm.threshold === 'number' &&\n        !isNaN(usm.threshold) &&\n        usm.threshold === 0);\n}\nexport { setTransformOptions };\n//# sourceMappingURL=imageTransformOptions.js.map","import { isSEOBot, getFileType, getFileName, getFileExtension, getDevicePixelRatio, getUpscaleString, isImageTransformApplicable, } from '../helpers/imageServiceUtils';\nimport { isMobile } from '../helpers/browserFeatureSupport';\nimport { setTransformParts } from '../helpers/imageTransformParts';\nimport { setTransformOptions } from '../helpers/imageTransformOptions';\nimport { MOBILE_MAX_BG_SITE_LEGACY_WIDTH, DSKTP_MAX_BG_SITE_LEGACY_WIDTH, MOBILE_MAX_BG_SITE_LEGACY_HEIGHT, DSKTP_MAX_BG_SITE_LEGACY_HEIGHT, fittingTypes, } from '../helpers/imageServiceConstants';\n/**\n * returns image transform data\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   [options]           transform options\n *\n * @returns {ImageTransformObject}\n */\nfunction getTransform(fittingType, src, target, options) {\n    const _isSEOBot = isSEOBot(options);\n    const fileType = getFileType(src.id);\n    const fileName = getFileName(src.id, src.name);\n    const devicePixelRatio = _isSEOBot ? 1 : getDevicePixelRatio(target);\n    const fileExtension = getFileExtension(src.id);\n    const preferredExtension = fileExtension;\n    const canTransformImage = isImageTransformApplicable(src.id);\n    const transformsObj = {\n        fileName,\n        fileExtension,\n        fileType,\n        fittingType,\n        preferredExtension,\n        src: {\n            id: src.id,\n            width: src.width,\n            height: src.height,\n            isCropped: false,\n        },\n        focalPoint: {\n            x: src.focalPoint && src.focalPoint.x,\n            y: src.focalPoint && src.focalPoint.y,\n        },\n        parts: [],\n        // options - general\n        devicePixelRatio,\n        quality: 0,\n        upscaleMethod: getUpscaleString(options),\n        progressive: true,\n        watermark: '',\n        unsharpMask: {},\n        filters: {},\n        transformed: canTransformImage,\n    };\n    if (canTransformImage) {\n        setTransformParts(transformsObj, src, target);\n        setTransformOptions(transformsObj, options);\n    }\n    return transformsObj;\n}\n/**\n * returns target data\n * handle legacy BG site if needed\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n *\n * @returns {Object}\n */\nfunction getTarget(fittingType, src, target) {\n    const targetObj = Object.assign({}, target);\n    const _isMobile = isMobile();\n    // handle site BG legacy fitting types (desktop & mobile)\n    switch (fittingType) {\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:\n        case fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:\n        case fittingTypes.LEGACY_BG_NORMAL:\n            const maxBGSiteLegacyWidth = _isMobile\n                ? MOBILE_MAX_BG_SITE_LEGACY_WIDTH\n                : DSKTP_MAX_BG_SITE_LEGACY_WIDTH;\n            const maxBGSiteLegacyHeight = _isMobile\n                ? MOBILE_MAX_BG_SITE_LEGACY_HEIGHT\n                : DSKTP_MAX_BG_SITE_LEGACY_HEIGHT;\n            targetObj.width = Math.min(maxBGSiteLegacyWidth, src.width);\n            targetObj.height = Math.min(maxBGSiteLegacyHeight, Math.round(targetObj.width / (src.width / src.height)));\n            // for legacy types force htmlTag='bg' and devicePixelRatio=1\n            targetObj.pixelAspectRatio = 1;\n    }\n    return targetObj;\n}\nexport { getTransform, getTarget };\n//# sourceMappingURL=transform.js.map","import { template } from '../helpers/utils';\nimport { imageFilters, transformTypes, API_VERSION, fileType, } from '../helpers/imageServiceConstants';\n// transform templates\nconst fitTemplate = template `fit/w_${'width'},h_${'height'}`;\nconst fillTemplate = template `fill/w_${'width'},h_${'height'},al_${'alignment'}`;\nconst fillFocalTemplate = template `fill/w_${'width'},h_${'height'},fp_${'focalPointX'}_${'focalPointY'}`;\nconst cropTemplate = template `crop/x_${'x'},y_${'y'},w_${'width'},h_${'height'}`;\n// legacy templates\nconst legacyCropTemplate = template `crop/w_${'width'},h_${'height'},al_${'alignment'}`;\nconst legacyFillTemplate = template `fill/w_${'width'},h_${'height'},al_${'alignment'}`;\n// upscale template\nconst upscaleTemplate = template `,lg_${'upscaleMethodValue'}`;\n// options templates\nconst qualityTemplate = template `,q_${'quality'}`;\nconst unSharpMaskTemplate = template `,usm_${'radius'}_${'amount'}_${'threshold'}`;\nconst nonProgressiveTemplate = template `,bl`;\nconst watermarkTemplate = template `,wm_${'watermark'}`;\nconst filterTemplatesMap = {\n    [imageFilters.CONTRAST]: template `,con_${'contrast'}`,\n    [imageFilters.BRIGHTNESS]: template `,br_${'brightness'}`,\n    [imageFilters.SATURATION]: template `,sat_${'saturation'}`,\n    [imageFilters.HUE]: template `,hue_${'hue'}`,\n    [imageFilters.BLUR]: template `,blur_${'blur'}`,\n};\nconst autoEncodeTemplate = template `,enc_auto`;\n/**\n * returns image transform uri\n * @param {object}  transformsObj\n *\n * @returns {string}\n */\nfunction getImageURI(transformsObj) {\n    // construct image transforms\n    const transformsObjStrArr = [];\n    // construct transform\n    transformsObj.parts.forEach((transformPart) => {\n        switch (transformPart.transformType) {\n            case transformTypes.CROP:\n                transformsObjStrArr.push(cropTemplate(transformPart));\n                break;\n            case transformTypes.LEGACY_CROP:\n                transformsObjStrArr.push(legacyCropTemplate(transformPart));\n                break;\n            case transformTypes.LEGACY_FILL:\n                let legacyFillStr = legacyFillTemplate(transformPart);\n                if (transformPart.upscale) {\n                    legacyFillStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(legacyFillStr);\n                break;\n            case transformTypes.FIT:\n                let fitStr = fitTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fitStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fitStr);\n                break;\n            case transformTypes.FILL:\n                let fillStr = fillTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fillStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fillStr);\n                break;\n            case transformTypes.FILL_FOCAL:\n                let fillFocalStr = fillFocalTemplate(transformPart);\n                if (transformPart.upscale) {\n                    fillFocalStr += upscaleTemplate(transformPart);\n                }\n                transformsObjStrArr.push(fillFocalStr);\n                break;\n        }\n    });\n    let transformsStr = transformsObjStrArr.join('/');\n    // construct transform options\n    // quality\n    if (transformsObj.quality) {\n        transformsStr += qualityTemplate(transformsObj);\n    }\n    // un-sharp mask\n    if (transformsObj.unsharpMask) {\n        transformsStr += unSharpMaskTemplate(transformsObj.unsharpMask);\n    }\n    // progressive\n    if (!transformsObj.progressive) {\n        transformsStr += nonProgressiveTemplate(transformsObj);\n    }\n    // watermark\n    if (transformsObj.watermark) {\n        transformsStr += watermarkTemplate(transformsObj);\n    }\n    // filters\n    if (transformsObj.filters) {\n        transformsStr += Object.keys(transformsObj.filters)\n            .map((filterName) => filterTemplatesMap[filterName](transformsObj.filters))\n            .join('');\n    }\n    // auto encode\n    if (transformsObj.autoEncode && transformsObj.fileType !== fileType.GIF) {\n        transformsStr += autoEncodeTemplate(transformsObj);\n    }\n    // image url string\n    return `${transformsObj.src.id}/${API_VERSION}/${transformsStr}/${transformsObj.fileName}.${transformsObj.preferredExtension}`;\n}\nexport { getImageURI };\n//# sourceMappingURL=transforms.js.map","import { isImageTransformApplicable } from '../helpers/imageServiceUtils';\nimport { getImageURI } from '../engines/transforms';\nimport { getTransform } from './transform';\n/**\n * returns image transform uri\n *\n * @param {string}                  fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   options             transform options\n * @param {Object}                  [transformObj]      transform data object to use\n *\n * @returns {string}\n */\nfunction getURI(fittingType, src, target, options = {}, transformObj) {\n    // check if image transformation is applicable (e.g. .gif, .wix_mp)\n    if (isImageTransformApplicable(src.id)) {\n        transformObj =\n            transformObj || getTransform(fittingType, src, target, options);\n        // set the uri property\n        return getImageURI(transformObj);\n    }\n    return src.id;\n}\nexport { getURI };\n//# sourceMappingURL=uri.js.map","import { alignTypes, fittingTypes } from './imageServiceConstants';\nimport { isPNG } from './imageServiceUtils';\nconst ALIGN_TYPE_TO_POSITION = {\n    [alignTypes.CENTER]: '50% 50%',\n    [alignTypes.TOP_LEFT]: '0% 0%',\n    [alignTypes.TOP_RIGHT]: '100% 0%',\n    [alignTypes.TOP]: '50% 0%',\n    [alignTypes.BOTTOM_LEFT]: '0% 100%',\n    [alignTypes.BOTTOM_RIGHT]: '100% 100%',\n    [alignTypes.BOTTOM]: '50% 100%',\n    [alignTypes.RIGHT]: '100% 50%',\n    [alignTypes.LEFT]: '0% 50%',\n};\nconst POSITION_TO_ALIGN_TYPE = Object.entries(ALIGN_TYPE_TO_POSITION).reduce((acc, [align, position]) => {\n    acc[position] = align;\n    return acc;\n}, {});\nconst TILE_FITTING_TYPES = [\n    fittingTypes.TILE,\n    fittingTypes.TILE_HORIZONTAL,\n    fittingTypes.TILE_VERTICAL,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL,\n    fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL,\n];\nconst NON_SCALING_FITTING_TYPES = [\n    fittingTypes.LEGACY_ORIGINAL_SIZE,\n    fittingTypes.ORIGINAL_SIZE,\n    fittingTypes.LEGACY_BG_NORMAL,\n];\nfunction getIsFakeTile(fittingType, src, { width: targetWidth, height: targetHeight, }) {\n    return (fittingType === fittingTypes.TILE &&\n        src.width > targetWidth &&\n        src.height > targetHeight);\n}\n/**\n *\n * @param {FittingType}             fittingType      imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src              source image\n * @param {Dimensions}              target           target container dimensions\n * @param {boolean}                 [isSEOBot=false] whether it is a render for a bot request\n * @returns {Dimensions} scaled dimensions\n */\nfunction getScaledDimensions(fittingType, src, { width, height }, isSEOBot = false) {\n    if (isSEOBot) {\n        return { width, height };\n    }\n    const isScalable = !NON_SCALING_FITTING_TYPES.includes(fittingType);\n    const isFakeTile = getIsFakeTile(fittingType, src, { width, height });\n    const isTile = !isFakeTile && TILE_FITTING_TYPES.includes(fittingType);\n    const _width = isTile ? src.width : width;\n    const _height = isTile ? src.height : height;\n    const scaleFactor = isScalable\n        ? getScaleFactorByWidth(_width, isPNG(src.id))\n        : 1;\n    return {\n        width: isFakeTile ? 1920 : _width * scaleFactor,\n        height: _height * scaleFactor,\n    };\n}\n/**\n *\n * @param {FittingType} fittingType  imageServicesTypes.fittingTypes\n * @param {boolean} isFakeTile\n * @returns {string} fittingType\n */\nfunction getConvertedFitting(fittingType, isFakeTile) {\n    const isTile = TILE_FITTING_TYPES.includes(fittingType) && !isFakeTile;\n    const isFill = fittingType === fittingTypes.SCALE_TO_FILL;\n    return isFill || isTile ? fittingTypes.SCALE_TO_FIT : fittingType;\n}\n/**\n *\n * @param {ImageTransformSource}    src                 source image\n * @param {number || ''}            width\n * @param {number || ''}            height\n * @returns {Dimensions}    width, height\n */\nfunction validateTargetDimensions(src, { width, height }) {\n    if (!width || !height) {\n        const _width = width || Math.min(980, src.width);\n        const heightRatio = _width / src.width;\n        return {\n            width: _width,\n            height: height || src.height * heightRatio,\n        };\n    }\n    return { width, height };\n}\n/**\n *\n * @param {number} width\n * @param {boolean} isHighQuality\n * @return {number}\n */\nfunction getScaleFactorByWidth(width, isHighQuality) {\n    if (width > 900) {\n        return isHighQuality ? 0.05 : 0.15;\n    }\n    else if (width > 500) {\n        return isHighQuality ? 0.1 : 0.18;\n    }\n    else if (width > 200) {\n        return 0.25;\n    }\n    return 1;\n}\n/**\n *\n * @param {number} width\n * @param {FittingType} fittingType imageServicesTypes.fittingTypes\n * @param {boolean} isSEOBot\n * @return {number}\n */\nfunction getBlurValue(width, fittingType, isSEOBot) {\n    if (isSEOBot) {\n        return 0;\n    }\n    if (TILE_FITTING_TYPES.includes(fittingType)) {\n        return 1;\n    }\n    if (width > 200) {\n        return 2;\n    }\n    return 3;\n}\n/**\n *\n * @param {FittingType}                       fittingType\n * @param {ImageTransformSource}              src                  source image\n * @param {{width?: number; height?: number}} target               target element\n * @param {string}                            [alignment='center']\n * @returns {{img}, {container}}\n */\nfunction getCSSOverrides(fittingType, src, target, alignment = 'center') {\n    const returnValue = {\n        img: {},\n        container: {},\n    };\n    if (fittingType === fittingTypes.SCALE_TO_FILL) {\n        const alignTypeFromFocalPoint = src.focalPoint && convertFocalPointToAlignType(src.focalPoint);\n        const alignType = alignTypeFromFocalPoint || alignment;\n        if (src.focalPoint && !alignTypeFromFocalPoint) {\n            returnValue.img = {\n                objectPosition: convertFillFocalToPosition(src, target, src.focalPoint),\n            };\n        }\n        else {\n            returnValue.img = {\n                objectPosition: ALIGN_TYPE_TO_POSITION[alignType],\n            };\n        }\n    }\n    else if ([fittingTypes.LEGACY_ORIGINAL_SIZE, fittingTypes.ORIGINAL_SIZE].includes(fittingType)) {\n        returnValue.img = {\n            objectFit: 'none',\n            top: 'auto',\n            left: 'auto',\n            right: 'auto',\n            bottom: 'auto',\n        };\n    }\n    else if (TILE_FITTING_TYPES.includes(fittingType)) {\n        returnValue.container = {\n            backgroundSize: `${src.width}px ${src.height}px`,\n        };\n    }\n    return returnValue;\n}\n/**\n * Try to convert focal point value to 9 grid alignment value\n *\n * @param {Point}    focalPoint\n * @returns {AlignType} align type\n */\nfunction convertFocalPointToAlignType(focalPoint) {\n    const position = `${focalPoint.x}% ${focalPoint.y}%`;\n    return POSITION_TO_ALIGN_TYPE[position] || '';\n}\n/**\n *\n * @param {Dimensions} src source dimensions\n * @param {width?: number; height?: number} target target dimensions\n * @param {Point} focalPoint x/y as 0-100 percentages\n * @returns {string} in 'x% y%' format\n */\nfunction convertFillFocalToPosition(src, target, focalPoint) {\n    const { width: sW, height: sH } = src;\n    const { width: tW, height: tH } = target;\n    const { x: fpX, y: fpY } = focalPoint;\n    if (!tW || !tH) {\n        return `${fpX}% ${fpY}%`;\n    }\n    const fillScaleFactor = Math.max(tW / sW, tH / sH);\n    const imgScaledW = sW * fillScaleFactor;\n    const imgScaledH = sH * fillScaleFactor;\n    const x = Math.max(0, Math.min(imgScaledW - tW, imgScaledW * (fpX / 100) - tW / 2));\n    const y = Math.max(0, Math.min(imgScaledH - tH, imgScaledH * (fpY / 100) - tH / 2));\n    const posX = x && Math.floor((x / (imgScaledW - tW)) * 100);\n    const posY = y && Math.floor((y / (imgScaledH - tH)) * 100);\n    return `${posX}% ${posY}%`;\n}\nexport { getBlurValue, getConvertedFitting, getCSSOverrides, getIsFakeTile, getScaledDimensions, validateTargetDimensions, };\n//# sourceMappingURL=imagePlaceholderUtils.js.map","import { emptyData } from '../../helpers/imageServiceConstants';\nimport { isImageTransformApplicable, isValidRequest, } from '../../helpers/imageServiceUtils';\nimport { getAttributes } from '../../engines/attributes';\nimport { getTransform, getTarget } from '../transform';\nimport { getURI } from '../uri';\nimport { getSrcset } from '../srcset';\nimport { getScaledDimensions, getBlurValue, getCSSOverrides, validateTargetDimensions, getIsFakeTile, getConvertedFitting, } from '../../helpers/imagePlaceholderUtils';\nconst PLACEHOLDER_IMG_CSS_OVERRIDES = { width: '100%', height: '100%' };\n/**\n * returns image _placeholder_ transform uri and the\n * needed css for alignment and positioning\n *\n * @param {FittingType}             fittingType imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src         image\n * @param {ImagePlaceholderTransformTarget}    target      target dimensions\n * @param {ImageTransformOptions} [options]   environment / transformation  options\n *\n * @returns {ImageDataAttributes}\n */\nfunction getPlaceholder(fittingType, src, target, options = {}) {\n    if (!isValidRequest(fittingType, src, target)) {\n        return emptyData;\n    }\n    const { autoEncode = true, isSEOBot, shouldLoadHQImage } = options;\n    const canTransformImage = isImageTransformApplicable(src.id);\n    if (!canTransformImage || shouldLoadHQImage) {\n        /* Either:\n         * 1. Transform isn't applicable so target is original size applied with fluid CSS\n         * 2. User asked for an HQ image, so they must have supplied target size (width/height)\n         */\n        return getData(fittingType, src, target, Object.assign(Object.assign({}, options), { autoEncode, useSrcset: canTransformImage }));\n    }\n    // If there aren't dimensions, we make them up\n    const newTarget = Object.assign(Object.assign({}, target), validateTargetDimensions(src, target));\n    const { alignment, htmlTag } = newTarget;\n    const isFakeTile = getIsFakeTile(fittingType, src, newTarget);\n    const scaledDimensions = getScaledDimensions(fittingType, src, newTarget, isSEOBot);\n    const blur = getBlurValue(newTarget.width, fittingType, isSEOBot);\n    const convertedFittingType = getConvertedFitting(fittingType, isFakeTile);\n    const overrideCSS = getCSSOverrides(fittingType, src, target, alignment);\n    const { uri } = getData(convertedFittingType, src, Object.assign(Object.assign({}, scaledDimensions), { alignment,\n        htmlTag }), {\n        autoEncode,\n        filters: blur ? { blur } : {},\n    });\n    const { attr = {}, css } = getData(fittingType, src, Object.assign(Object.assign({}, newTarget), { alignment,\n        htmlTag }), {});\n    css.img = css.img || {};\n    css.container = css.container || {};\n    Object.assign(css.img, overrideCSS.img, PLACEHOLDER_IMG_CSS_OVERRIDES);\n    Object.assign(css.container, overrideCSS.container);\n    return { uri, css, attr, transformed: true };\n}\n/**\n * returns image transform uri and the\n * needed css for alignment and positioning\n *\n * @param {FittingType}             fittingType         imageServicesTypes.fittingTypes\n * @param {ImageTransformSource}    src                 source image\n * @param {ImageTransformTarget}    target              target component\n * @param {ImageTransformOptions}   [options]          transform options\n *\n * @returns {ImageDataAttributes}\n */\nfunction getData(fittingType, src, target, options) {\n    let data = {};\n    // check if valid request\n    if (isValidRequest(fittingType, src, target)) {\n        // handle site BG legacy fitting types if needed\n        const targetObj = getTarget(fittingType, src, target);\n        // parse request and create working OBJ\n        const transformObj = getTransform(fittingType, src, targetObj, options);\n        data.uri = getURI(fittingType, src, targetObj, options, transformObj);\n        if (options === null || options === void 0 ? void 0 : options.useSrcset) {\n            data.srcset = getSrcset(fittingType, src, targetObj, options, data);\n        }\n        // set the CSS or the SVG property\n        Object.assign(data, getAttributes(transformObj, targetObj), {\n            transformed: transformObj.transformed,\n        });\n    }\n    else {\n        // empty data\n        data = emptyData;\n    }\n    // return data to be used in html\n    return data;\n}\nexport { getData, getPlaceholder };\n//# sourceMappingURL=api.js.map","import { getURI } from './uri';\nfunction getSrcset(fittingType, src, target, options, data) {\n    const dpr = target.pixelAspectRatio || 1;\n    return {\n        dpr: [\n            `${dpr === 1\n                ? data.uri\n                : getURI(fittingType, src, Object.assign(Object.assign({}, target), { pixelAspectRatio: 1 }), options)} 1x`,\n            `${dpr === 2\n                ? data.uri\n                : getURI(fittingType, src, Object.assign(Object.assign({}, target), { pixelAspectRatio: 2 }), options)} 2x`,\n        ],\n    };\n}\nexport { getSrcset };\n//# sourceMappingURL=srcset.js.map","import { htmlTag } from '../helpers/imageServiceConstants';\nimport { get as backgroundAttributes } from './attributes/backgroundAttributes';\nimport { get as imgAttributes } from './attributes/imgAttributes';\nimport { get as SVGAttributes } from './attributes/SVGAttributes';\n/**\n * get CSS or SVG attributes to be used in the browser\n * @param {ImageTransformObject}    transformsObj    transform parts object\n * @param {ImageTransformTarget}    target\n *\n * @returns object\n */\nfunction getAttributes(transformsObj, target) {\n    let attributesGetter;\n    if (target.htmlTag === htmlTag.BG) {\n        attributesGetter = backgroundAttributes;\n    }\n    else if (target.htmlTag === htmlTag.SVG) {\n        attributesGetter = SVGAttributes;\n    }\n    else {\n        attributesGetter = imgAttributes;\n    }\n    return attributesGetter(transformsObj, target);\n}\nexport { getAttributes };\n//# sourceMappingURL=attributes.js.map","import { getData, populateGlobalFeatureSupport } from '../api/uri/index';\nimport { fittingTypes, htmlTag, alignTypes, } from '../helpers/imageServiceConstants';\nconst wixStatic = 'https://static.wixstatic.com/';\nconst wixStaticWithMedia = 'https://static.wixstatic.com/media/';\nconst HAS_MEDIA_PREFIX_RE = /^media\\//i;\nconst devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\nconst getWixStaticURL = (uri) => HAS_MEDIA_PREFIX_RE.test(uri)\n    ? `${wixStatic}${uri}`\n    : `${wixStaticWithMedia}${uri}`;\nconst getURL = (uri, options) => {\n    const baseHostURL = options && options.baseHostURL;\n    return baseHostURL ? `${baseHostURL}${uri}` : getWixStaticURL(uri);\n};\nfunction getScaleToFitImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FIT, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nfunction getScaleToFillImageURL(relativeUrl, sourceWidth, sourceHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FILL, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n        focalPoint: {\n            x: options && options.focalPoint && options.focalPoint.x,\n            y: options && options.focalPoint && options.focalPoint.y,\n        },\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nfunction getCropImageURL(relativeUrl, sourceWidth, sourceHeight, cropX, cropY, cropWidth, cropHeight, targetWidth, targetHeight, options) {\n    const data = getData(fittingTypes.SCALE_TO_FILL, {\n        id: relativeUrl,\n        width: sourceWidth,\n        height: sourceHeight,\n        name: options && options.name,\n        crop: {\n            x: cropX,\n            y: cropY,\n            width: cropWidth,\n            height: cropHeight,\n        },\n    }, {\n        width: targetWidth,\n        height: targetHeight,\n        htmlTag: htmlTag.IMG,\n        alignment: alignTypes.CENTER,\n        pixelAspectRatio: devicePixelRatio,\n    }, options);\n    return getURL(data.uri, options);\n}\nexport { populateGlobalFeatureSupport, getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, };\n//# sourceMappingURL=api.js.map","import { populateGlobalFeatureSupport, getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, } from './api';\npopulateGlobalFeatureSupport();\nexport { getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStatic, wixStaticWithMedia, };\n//# sourceMappingURL=index.js.map","import { alignTypes, fittingTypes, htmlTag, upscaleMethods, } from '../../helpers/imageServiceConstants';\nimport { populateGlobalFeatureSupport } from '../../helpers/populateFeatureSupport';\nimport { getData, getPlaceholder } from './api';\nimport { getScaleToFitImageURL, getScaleToFillImageURL, getCropImageURL, wixStaticWithMedia, } from '../../sdk';\npopulateGlobalFeatureSupport();\nconst sdk = {\n    getScaleToFitImageURL,\n    getScaleToFillImageURL,\n    getCropImageURL,\n};\nexport * from '../../types';\nconst STATIC_MEDIA_URL = wixStaticWithMedia;\nexport { STATIC_MEDIA_URL, alignTypes, fittingTypes, getData, getPlaceholder, htmlTag, populateGlobalFeatureSupport, sdk, upscaleMethods, };\n//# sourceMappingURL=index.js.map"],"names":["fittingTypes","SCALE_TO_FILL","SCALE_TO_FIT","STRETCH","ORIGINAL_SIZE","TILE","TILE_HORIZONTAL","TILE_VERTICAL","FIT_AND_TILE","LEGACY_STRIP_TILE","LEGACY_STRIP_TILE_HORIZONTAL","LEGACY_STRIP_TILE_VERTICAL","LEGACY_STRIP_SCALE_TO_FILL","LEGACY_STRIP_SCALE_TO_FIT","LEGACY_STRIP_FIT_AND_TILE","LEGACY_STRIP_ORIGINAL_SIZE","LEGACY_ORIGINAL_SIZE","LEGACY_FIT_WIDTH","LEGACY_FIT_HEIGHT","LEGACY_FULL","LEGACY_BG_FIT_AND_TILE","LEGACY_BG_FIT_AND_TILE_HORIZONTAL","LEGACY_BG_FIT_AND_TILE_VERTICAL","LEGACY_BG_NORMAL","transformTypes","alignTypes","CENTER","TOP","TOP_LEFT","TOP_RIGHT","BOTTOM","BOTTOM_LEFT","BOTTOM_RIGHT","LEFT","RIGHT","ALIGN_TYPE_TO_FOCAL_POINT","x","y","alignTypesMap","center","top","top_left","top_right","bottom","bottom_left","bottom_right","left","right","htmlTag","BG","IMG","SVG","upscaleMethods","AUTO","CLASSIC","SUPER","upscaleMethodsValues","defaultUSM","radius","amount","threshold","emptyData","uri","css","img","container","attr","transformed","SAFE_TRANSFORMED_AREA","MAX_TRANSFORMED_IMAGE_WIDTH","SUPER_UPSCALE_MODELS","imageScaleDefaults","HIGH","size","quality","maxUpscale","MEDIUM","LOW","TINY","imageQuality","imageFilters","fileType","globalFeaturesSupportObj","isMobile","populateGlobalFeatureSupport","window","navigator","isSmallScreen","matchMedia","matches","isMobileAgent","test","userAgent","value","template","strings","keys","values","dict","length","result","forEach","key","i","Number","isInteger","push","join","last","array","SUPPORTED_IMAGE_EXTENSIONS","JPG_EXTENSIONS","isValidRequest","fittingType","src","target","url","id","trim","toLowerCase","Object","includes","isImageTransformApplicable","getFileExtension","isImageTypeSupported","isPNG","ILLEGAL_CHARS","map","encodeURIComponent","URL_SAFE_ILLEGAL_CHARS","getFileType","isJPG","isWEBP","exec","getScaleFactor","sWidth","sHeight","dWidth","dHeight","transformType","scaleFactor","Math","max","getFillScaleFactor","min","getFitScaleFactor","getTransformData","dpr","upscaleMethod","width","height","dimensionScaleFactor","sqrt","getSafeTransformData","tWidth","tHeight","optimizedScaleFactor","upscaleMethodValue","forceUSM","imageKey","getImageQualityKey","getAutoScaleData","getSuperScaleData","getClassicScaleData","getOptimizedScaleData","cssUpscaleNeeded","getOptimizedTransformData","getAlignedRect","sRect","dRect","sFP","alignment","fp","getFocalPoint","getFocalPointFrom9GridAlignment","getAlignment","focalPoint","isNaN","roundToFixed","imageWidth","imageHeight","precision","truncatePrecision","pow","toFixed","getUpscaleString","options","toUpperCase","getCSS","transformsObj","attributes","backgroundSize","backgroundRepeat","backgroundPosition","alignTypeToPositionStr","aligmentDefaults","position","alignType","parts","objectFit","objectPosition","verticalMiddle","round","horizontalMiddle","assign","alignTypeToPosition","getSvgAttr","sourceWidth","sourceHeight","imageScale","preserveAspectRatio","transform","getDimension","middle","viewBox","setTransformParts","rect","crop","getOverlappingRect","isCropped","getCropPart","getFitPart","transformedData","devicePixelRatio","focalPointX","focalPointY","upscale","getFillPart","clonedTarget","getStretchPart","getLegacyCropPart","getLegacyFitPart","getLegacyFillPart","setTransformOptions","_a","transformData","defaultQuality","getQuality","progressive","getProgressive","watermark","getWatermark","autoEncode","unsharpMask","_b","_c","usm","isUSMValid","transformPart","isUSMNeeded","getUnsharpMask","filters","filterOptions","isValidImageFilter","getFilters","filterValue","minValue","maxValue","getTransform","_isSEOBot","isSEOBot","fileName","name","fileExtensionRegexp","illegalCharsRegex","RegExp","concat","extension","match","replace","trimmed","getFileName","pixelAspectRatio","getDevicePixelRatio","fileExtension","preferredExtension","canTransformImage","getTarget","targetObj","_isMobile","maxBGSiteLegacyWidth","maxBGSiteLegacyHeight","fitTemplate","fillTemplate","fillFocalTemplate","cropTemplate","legacyCropTemplate","legacyFillTemplate","upscaleTemplate","qualityTemplate","unSharpMaskTemplate","nonProgressiveTemplate","watermarkTemplate","filterTemplatesMap","autoEncodeTemplate","getURI","transformObj","transformsObjStrArr","legacyFillStr","fitStr","fillStr","fillFocalStr","transformsStr","filterName","getImageURI","ALIGN_TYPE_TO_POSITION","POSITION_TO_ALIGN_TYPE","entries","reduce","acc","align","TILE_FITTING_TYPES","NON_SCALING_FITTING_TYPES","getIsFakeTile","targetWidth","targetHeight","getCSSOverrides","returnValue","alignTypeFromFocalPoint","convertFocalPointToAlignType","convertFillFocalToPosition","sW","sH","tW","tH","fpX","fpY","fillScaleFactor","imgScaledW","imgScaledH","floor","PLACEHOLDER_IMG_CSS_OVERRIDES","getPlaceholder","shouldLoadHQImage","getData","useSrcset","newTarget","_width","heightRatio","validateTargetDimensions","isFakeTile","scaledDimensions","isScalable","isTile","_height","isHighQuality","getScaleFactorByWidth","getScaledDimensions","blur","getBlurValue","convertedFittingType","getConvertedFitting","overrideCSS","data","srcset","getSrcset","attributesGetter","getAttributes","wixStaticWithMedia","HAS_MEDIA_PREFIX_RE","getURL","baseHostURL","getWixStaticURL","sdk","getScaleToFitImageURL","relativeUrl","getScaleToFillImageURL","getCropImageURL","cropX","cropY","cropWidth","cropHeight","STATIC_MEDIA_URL"],"sourceRoot":""}